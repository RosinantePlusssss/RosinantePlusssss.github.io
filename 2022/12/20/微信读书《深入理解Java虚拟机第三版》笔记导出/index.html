<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"rosinanteplusssss.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）周志明">
<meta property="og:type" content="article">
<meta property="og:title" content="微信读书《深入理解Java虚拟机第三版》笔记导出">
<meta property="og:url" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/index.html">
<meta property="og:site_name" content="日復一日">
<meta property="og:description" content="深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）周志明">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png">
<meta property="og:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png">
<meta property="og:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png">
<meta property="og:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.png">
<meta property="og:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png">
<meta property="og:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/OSGi%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.png">
<meta property="og:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png">
<meta property="og:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96.png">
<meta property="article:published_time" content="2022-12-20T10:46:25.000Z">
<meta property="article:modified_time" content="2023-01-03T09:27:49.815Z">
<meta property="article:author" content="Yellow">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Jvm">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png">


<link rel="canonical" href="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/","path":"2022/12/20/微信读书《深入理解Java虚拟机第三版》笔记导出/","title":"微信读书《深入理解Java虚拟机第三版》笔记导出"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>微信读书《深入理解Java虚拟机第三版》笔记导出 | 日復一日</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">日復一日</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">當一個堅持的人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Table-of-Contents"><span class="nav-number">1.</span> <span class="nav-text">Table of Contents</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="nav-number">2.</span> <span class="nav-text">第2章 Java内存区域与内存溢出异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F"><span class="nav-number">2.1.</span> <span class="nav-text">2.2 运行时数据区域</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.2.1 程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.2.2 Java虚拟机栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-Java%E5%A0%86"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.2.4 Java堆</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.2.5 方法区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-6-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.1.5.</span> <span class="nav-text">2.2.6 运行时常量池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-7-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">2.1.6.</span> <span class="nav-text">2.2.7 直接内存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98"><span class="nav-number">2.2.</span> <span class="nav-text">2.3 HotSpot虚拟机对象探秘</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.3.1 对象的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.3.2 对象的内存布局</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">3.</span> <span class="nav-text">第3章 垃圾收集器与内存分配策略</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E5%AF%B9%E8%B1%A1%E5%B7%B2%E6%AD%BB%E5%90%97"><span class="nav-number">3.1.</span> <span class="nav-text">3.2 对象已死吗</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.2.2 可达性分析算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-%E5%9B%9E%E6%94%B6%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.2.5 回收方法区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">3.3 垃圾收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.3.1 标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.3.2 复制算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.3.3 标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.5.2 ParNew收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.5.3 Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.6.</span> <span class="nav-text">3.5.4 Serial Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.7.</span> <span class="nav-text">3.5.5 Parallel Old收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-6-CMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.8.</span> <span class="nav-text">3.5.6 CMS收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-7-G1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.2.9.</span> <span class="nav-text">3.5.7 G1收集器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0-%E8%B0%83%E4%BC%98%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98"><span class="nav-number">4.</span> <span class="nav-text">第5章 调优案例分析与实战</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">5.</span> <span class="nav-text">第6章 类文件结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="nav-number">6.</span> <span class="nav-text">第7章 虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA"><span class="nav-number">6.1.</span> <span class="nav-text">7.2 类加载的时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="nav-number">6.2.</span> <span class="nav-text">7.3 类加载的过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-%E5%8A%A0%E8%BD%BD"><span class="nav-number">6.2.1.</span> <span class="nav-text">7.3.1 加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-%E9%AA%8C%E8%AF%81"><span class="nav-number">6.2.2.</span> <span class="nav-text">7.3.2 验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-%E5%87%86%E5%A4%87"><span class="nav-number">6.2.3.</span> <span class="nav-text">7.3.3 准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-4-%E8%A7%A3%E6%9E%90"><span class="nav-number">6.2.4.</span> <span class="nav-text">7.3.4 解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-5-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">6.2.5.</span> <span class="nav-text">7.3.5 初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">6.3.</span> <span class="nav-text">7.4 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-1-%E7%B1%BB%E4%B8%8E%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-number">6.3.1.</span> <span class="nav-text">7.4.1 类与类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-2-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.3.2.</span> <span class="nav-text">7.4.2 双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-3-%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.3.3.</span> <span class="nav-text">7.4.3 破坏双亲委派模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC8%E7%AB%A0-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E"><span class="nav-number">7.</span> <span class="nav-text">第8章 虚拟机字节码执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88%E5%B8%A7%E7%BB%93%E6%9E%84"><span class="nav-number">7.1.</span> <span class="nav-text">8.2 运行时栈帧结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%A1%A8"><span class="nav-number">7.1.1.</span> <span class="nav-text">8.2.1 局部变量表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="nav-number">7.2.</span> <span class="nav-text">8.3 方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-1-%E8%A7%A3%E6%9E%90"><span class="nav-number">7.2.1.</span> <span class="nav-text">8.3.1 解析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC12%E7%AB%A0-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">8.</span> <span class="nav-text">第12章 Java内存模型与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%95%88%E7%8E%87%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">8.1.</span> <span class="nav-text">12.2 硬件的效率与一致性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.2.</span> <span class="nav-text">12.3 Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-1-%E4%B8%BB%E5%86%85%E5%AD%98%E4%B8%8E%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98"><span class="nav-number">8.2.1.</span> <span class="nav-text">12.3.1 主内存与工作内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-2-%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92%E6%93%8D%E4%BD%9C"><span class="nav-number">8.2.2.</span> <span class="nav-text">12.3.2 内存间交互操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-3-%E5%AF%B9%E4%BA%8Evolatile%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="nav-number">8.2.3.</span> <span class="nav-text">12.3.3 对于volatile型变量的特殊规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-5-%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%B8%8E%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="nav-number">8.2.4.</span> <span class="nav-text">12.3.5 原子性、可见性与有序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-6-%E5%85%88%E8%A1%8C%E5%8F%91%E7%94%9F%E5%8E%9F%E5%88%99"><span class="nav-number">8.2.5.</span> <span class="nav-text">12.3.6 先行发生原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-Java%E4%B8%8E%E7%BA%BF%E7%A8%8B"><span class="nav-number">8.3.</span> <span class="nav-text">12.4 Java与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-2-Java%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="nav-number">8.3.1.</span> <span class="nav-text">12.4.2 Java线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-3-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">8.3.2.</span> <span class="nav-text">12.4.3 状态转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC13%E7%AB%A0-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">9.</span> <span class="nav-text">第13章 线程安全与锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">9.1.</span> <span class="nav-text">13.2 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-1-Java%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">9.1.1.</span> <span class="nav-text">13.2.1 Java语言中的线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-2-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="nav-number">9.1.2.</span> <span class="nav-text">13.2.2 线程安全的实现方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-%E9%94%81%E4%BC%98%E5%8C%96"><span class="nav-number">9.2.</span> <span class="nav-text">13.3 锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-1-%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E8%87%AA%E9%80%82%E5%BA%94%E8%87%AA%E6%97%8B"><span class="nav-number">9.2.1.</span> <span class="nav-text">13.3.1 自旋锁与自适应自旋</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-2-%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">9.2.2.</span> <span class="nav-text">13.3.2 锁消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-3-%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">9.2.3.</span> <span class="nav-text">13.3.3 锁粗化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-4-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="nav-number">9.2.4.</span> <span class="nav-text">13.3.4 轻量级锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-3-5-%E5%81%8F%E5%90%91%E9%94%81"><span class="nav-number">9.2.5.</span> <span class="nav-text">13.3.5 偏向锁</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yellow"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yellow</p>
  <div class="site-description" itemprop="description">碼農</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/rosinanteplusssss" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rosinanteplusssss" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yellowdingjr@gmail.com" title="E-Mail → mailto:yellowdingjr@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rosinanteplusssss.github.io/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yellow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日復一日">
      <meta itemprop="description" content="碼農">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="微信读书《深入理解Java虚拟机第三版》笔记导出 | 日復一日">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          微信读书《深入理解Java虚拟机第三版》笔记导出
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-20 18:46:25" itemprop="dateCreated datePublished" datetime="2022-12-20T18:46:25+08:00">2022-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-03 17:27:49" itemprop="dateModified" datetime="2023-01-03T17:27:49+08:00">2023-01-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>1:01</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）<br>周志明</p>
<span id="more"></span>
<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol>
<li><a href="#org701c9c9">第2章 Java内存区域与内存溢出异常</a><ol>
<li><a href="#org25fabb8">2.2 运行时数据区域</a><ol>
<li><a href="#orgc208361">2.2.1 程序计数器</a></li>
<li><a href="#orgab97653">2.2.2 Java虚拟机栈</a></li>
<li><a href="#org4fa38d2">2.2.4 Java堆</a></li>
<li><a href="#org0e678d4">2.2.5 方法区</a></li>
<li><a href="#org43314eb">2.2.6 运行时常量池</a></li>
<li><a href="#org0748a1a">2.2.7 直接内存</a></li>
</ol>
</li>
<li><a href="#org5d97abe">2.3 HotSpot虚拟机对象探秘</a><ol>
<li><a href="#org46ac052">2.3.1 对象的创建</a></li>
<li><a href="#org8e1d632">2.3.2 对象的内存布局</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#orgf5c5d23">第3章 垃圾收集器与内存分配策略</a><ol>
<li><a href="#org194a92a">3.2 对象已死吗</a><ol>
<li><a href="#org3c93bcd">3.2.2 可达性分析算法</a></li>
<li><a href="#org40ca4b0">3.2.5 回收方法区</a></li>
</ol>
</li>
<li><a href="#org1cc5e9b">3.3 垃圾收集算法</a><ol>
<li><a href="#orgde3af29">3.3.1 标记-清除算法</a></li>
<li><a href="#org81b23f9">3.3.2 复制算法</a></li>
<li><a href="#orgc269724">3.3.3 标记-整理算法</a></li>
<li><a href="#org9f3def3">3.5.2 ParNew收集器</a></li>
<li><a href="#org93fa3b3">3.5.3 Parallel Scavenge收集器</a></li>
<li><a href="#orgbb80270">3.5.4 Serial Old收集器</a></li>
<li><a href="#org182d65d">3.5.5 Parallel Old收集器</a></li>
<li><a href="#org5ef3b7c">3.5.6 CMS收集器</a></li>
<li><a href="#org392406e">3.5.7 G1收集器</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#org3080f56">第5章 调优案例分析与实战</a></li>
<li><a href="#org7823b00">第6章 类文件结构</a></li>
<li><a href="#orgfc0ac26">第7章 虚拟机类加载机制</a><ol>
<li><a href="#org3ad9b55">7.2 类加载的时机</a></li>
<li><a href="#org7812a0b">7.3 类加载的过程</a><ol>
<li><a href="#org0b5f36d">7.3.1 加载</a></li>
<li><a href="#org6f6cd99">7.3.2 验证</a></li>
<li><a href="#org587518b">7.3.3 准备</a></li>
<li><a href="#org6aefb0c">7.3.4 解析</a></li>
<li><a href="#org9b44106">7.3.5 初始化</a></li>
</ol>
</li>
<li><a href="#org3f680a8">7.4 类加载器</a><ol>
<li><a href="#orgdb9534f">7.4.1 类与类加载器</a></li>
<li><a href="#orgfeccbe1">7.4.2 双亲委派模型</a></li>
<li><a href="#orgaaa83a7">7.4.3 破坏双亲委派模型</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#org814c1d8">第8章 虚拟机字节码执行引擎</a><ol>
<li><a href="#org266de21">8.2 运行时栈帧结构</a><ol>
<li><a href="#org256e938">8.2.1 局部变量表</a></li>
</ol>
</li>
<li><a href="#org743a54e">8.3 方法调用</a><ol>
<li><a href="#orgbb8d3f1">8.3.1 解析</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#org635134f">第12章 Java内存模型与线程</a><ol>
<li><a href="#orgcbabd74">12.2 硬件的效率与一致性</a></li>
<li><a href="#orga0caaaf">12.3 Java内存模型</a><ol>
<li><a href="#orge5900d1">12.3.1 主内存与工作内存</a></li>
<li><a href="#orgb0da347">12.3.2 内存间交互操作</a></li>
<li><a href="#org8efa1d0">12.3.3 对于volatile型变量的特殊规则</a></li>
<li><a href="#org691cfeb">12.3.5 原子性、可见性与有序性</a></li>
<li><a href="#org390f025">12.3.6 先行发生原则</a></li>
</ol>
</li>
<li><a href="#orgd7ac1c1">12.4 Java与线程</a><ol>
<li><a href="#org0e698b7">12.4.2 Java线程调度</a></li>
<li><a href="#orgb7c5561">12.4.3 状态转换</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#orgc21f1eb">第13章 线程安全与锁优化</a><ol>
<li><a href="#org49130fe">13.2 线程安全</a><ol>
<li><a href="#orga374a04">13.2.1 Java语言中的线程安全</a></li>
<li><a href="#org9f3e48a">13.2.2 线程安全的实现方法</a></li>
</ol>
</li>
<li><a href="#orgb6d00f5">13.3 锁优化</a><ol>
<li><a href="#org42599a8">13.3.1 自旋锁与自适应自旋</a></li>
<li><a href="#org2b20faf">13.3.2 锁消除</a></li>
<li><a href="#org0f30bcc">13.3.3 锁粗化</a></li>
<li><a href="#orgd87bc65">13.3.4 轻量级锁</a></li>
<li><a href="#org7735aa9">13.3.5 偏向锁</a></li>
</ol>
</li>
</ol>
</li>
</ol>
<p><a id="org701c9c9"></a></p>
<h1 id="第2章-Java内存区域与内存溢出异常"><a href="#第2章-Java内存区域与内存溢出异常" class="headerlink" title="第2章 Java内存区域与内存溢出异常"></a>第2章 Java内存区域与内存溢出异常</h1><p><a id="org25fabb8"></a></p>
<h2 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2 运行时数据区域"></a>2.2 运行时数据区域</h2><ul>
<li>根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图2-1所示。</li>
</ul>
<img src="/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" class="" title="JVM内存区域">


<p><a id="orgc208361"></a></p>
<h3 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1 程序计数器"></a>2.2.1 程序计数器</h3><ul>
<li>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</li>
</ul>
<p><a id="orgab97653"></a></p>
<h3 id="2-2-2-Java虚拟机栈"><a href="#2-2-2-Java虚拟机栈" class="headerlink" title="2.2.2 Java虚拟机栈"></a>2.2.2 Java虚拟机栈</h3><ul>
<li><p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p>
</li>
<li><p>而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p>
</li>
<li><p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
</li>
</ul>
<p><a id="org4fa38d2"></a></p>
<h3 id="2-2-4-Java堆"><a href="#2-2-4-Java堆" class="headerlink" title="2.2.4 Java堆"></a>2.2.4 Java堆</h3><ul>
<li><p>对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>
</li>
<li><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”</p>
</li>
<li><p>从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。这些区域划分仅仅是一部分垃圾收集器的共同特性或者说设计风格而已，而非某个Java虚拟机具体实现的固有内存布局。。。但是到了今天，垃圾收集器技术与十年前已不可以同日而语，HotSpot里面也出现了不采用分代设计的新垃圾收集器。</p>
</li>
<li><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
</li>
</ul>
<p><a id="org0e678d4"></a></p>
<h3 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5 方法区"></a>2.2.5 方法区</h3><ul>
<li><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p>
</li>
<li><p>原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题</p>
</li>
<li><p>在目前已经发布的JDK 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。</p>
</li>
<li><p>JDK8完全废除了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间来代替。</p>
</li>
</ul>
<p><a id="org43314eb"></a></p>
<h3 id="2-2-6-运行时常量池"><a href="#2-2-6-运行时常量池" class="headerlink" title="2.2.6 运行时常量池"></a>2.2.6 运行时常量池</h3><ul>
<li>常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</li>
</ul>
<p><a id="org0748a1a"></a></p>
<h3 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7 直接内存"></a>2.2.7 直接内存</h3><ul>
<li>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现</li>
</ul>
<p><a id="org5d97abe"></a></p>
<h2 id="2-3-HotSpot虚拟机对象探秘"><a href="#2-3-HotSpot虚拟机对象探秘" class="headerlink" title="2.3 HotSpot虚拟机对象探秘"></a>2.3 HotSpot虚拟机对象探秘</h2><p><a id="org46ac052"></a></p>
<h3 id="2-3-1-对象的创建"><a href="#2-3-1-对象的创建" class="headerlink" title="2.3.1 对象的创建"></a>2.3.1 对象的创建</h3><ul>
<li><p>文中讨论的对象限于普通Java对象，不包括数组和Class对象等</p>
</li>
<li><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p>
</li>
<li><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。</p>
</li>
<li><p>假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）</p>
</li>
<li><p>如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</p>
</li>
<li><p>因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
</li>
<li><p>一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB）</p>
</li>
<li><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p>
</li>
<li><p>从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——&lt;init&gt;方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行&lt;init&gt;方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
</li>
</ul>
<p><a id="org8e1d632"></a></p>
<h3 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2 对象的内存布局"></a>2.3.2 对象的内存布局</h3><ul>
<li><p>在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
</li>
<li><p>目前主流的访问方式有使用句柄和直接指针两种。</p>
</li>
<li><p>如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
</li>
</ul>
<img src="/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" class="" title="通过句柄访问对象">

<ul>
<li>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</li>
</ul>
<img src="/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" class="" title="通过直接指针访问对象">

<ul>
<li><p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
</li>
<li><p>使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>
</li>
</ul>
<p><a id="orgf5c5d23"></a></p>
<h1 id="第3章-垃圾收集器与内存分配策略"><a href="#第3章-垃圾收集器与内存分配策略" class="headerlink" title="第3章 垃圾收集器与内存分配策略"></a>第3章 垃圾收集器与内存分配策略</h1><p><a id="org194a92a"></a></p>
<h2 id="3-2-对象已死吗"><a href="#3-2-对象已死吗" class="headerlink" title="3.2 对象已死吗"></a>3.2 对象已死吗</h2><p><a id="org3c93bcd"></a></p>
<h3 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h3><ul>
<li>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</li>
</ul>
<img src="/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%E5%88%A4%E5%AE%9A%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%8F%AF%E5%9B%9E%E6%94%B6.png" class="" title="可达性分析算法判定对象是否可回收">

<ul>
<li>在Java语言中，可作为GC Roots的对象包括下面几种：<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的 参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量</li>
<li>在方法区中常量引用的对象，譬如字符串常量池（StringTable）里的引用。</li>
<li>在本地方法栈中JNI （即通常所说的Native方法）引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、 OutOfMemoryEiTor）等，还有系统类加载器。</li>
<li>所有被同步锁（synchronized关键字）持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
</li>
</ul>
<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不 同，还可以有其他对象“临时性”地加入，共同构成完整GC Roots集合。譬如后文将会提到的分代收集 和局部回收（Partial GC）,如果只针对Java堆中某一块区域发起垃圾收集时（如最典型的只针对新生 代的垃圾收集），必须考虑到内存区域是虚拟机自己的实现细节（在用户视角里任何内存区域都是不可见的），更不是孤立封闭的，所以某个区域里的对象完全有可能被位于堆中其他区域的对象所引 用，这时候就需要将这些关联区域的对象也一并加入GC Roots集合中去，才能保证可达性分析的正确性。</p>
<p><a id="org40ca4b0"></a></p>
<h3 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5 回收方法区"></a>3.2.5 回收方法区</h3><ul>
<li><p>在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～99%的空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p>
</li>
<li><p>方法区的垃圾收集主要回收两部分内容：废弃常量和不再使用的类型。</p>
</li>
<li><p>类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
</li>
</ul>
<p><a id="org1cc5e9b"></a></p>
<h2 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3 垃圾收集算法"></a>3.3 垃圾收集算法</h2><ul>
<li><p>垃圾收集算法可以划分为“引用计数式垃圾收集”和“追踪式垃圾收集”两大类，也被称为“直接垃圾收集”和“间接垃圾收集”。主流Java虚拟机均为追踪式垃圾收集算法。</p>
</li>
<li><p>分代收集理论简历再两个分代假说之上：</p>
<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭。</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ol>
</li>
<li><p>根据分代理论将java堆划分不同的区域，垃圾收集器每次只回收其中某一个或者某些部分的区域。</p>
</li>
<li><p>为了解决回收时跨代引用的问题，分代收集理论添加第三条法则：</p>
<ol>
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数。</li>
</ol>
</li>
<li><p>根据第三条假说，在新生代建立一个全局数据结构去记录某小块的老年代内存会有跨代引用。发生Minor GC时，只需要将一小块的老年代加入GC Roots进行扫描。</p>
</li>
</ul>
<p><a id="orgde3af29"></a></p>
<h3 id="3-3-1-标记-清除算法"><a href="#3-3-1-标记-清除算法" class="headerlink" title="3.3.1 标记-清除算法"></a>3.3.1 标记-清除算法</h3><ul>
<li>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</li>
</ul>
<p><a id="org81b23f9"></a></p>
<h3 id="3-3-2-复制算法"><a href="#3-3-2-复制算法" class="headerlink" title="3.3.2 复制算法"></a>3.3.2 复制算法</h3><ul>
<li><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
</li>
<li><p>现在的商业虚拟机都采用这种收集算法来回收新生代</p>
</li>
</ul>
<p><a id="orgc269724"></a></p>
<h3 id="3-3-3-标记-整理算法"><a href="#3-3-3-标记-整理算法" class="headerlink" title="3.3.3 标记-整理算法"></a>3.3.3 标记-整理算法</h3><ul>
<li>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</li>
</ul>
<p><a id="org9f3def3"></a></p>
<h3 id="3-5-2-ParNew收集器"><a href="#3-5-2-ParNew收集器" class="headerlink" title="3.5.2 ParNew收集器"></a>3.5.2 ParNew收集器</h3><ul>
<li>ParNew收集器其实就是Serial收集器的多线程版本</li>
</ul>
<p><a id="org93fa3b3"></a></p>
<h3 id="3-5-3-Parallel-Scavenge收集器"><a href="#3-5-3-Parallel-Scavenge收集器" class="headerlink" title="3.5.3 Parallel Scavenge收集器"></a>3.5.3 Parallel Scavenge收集器</h3><ul>
<li><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器</p>
</li>
<li><p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）</p>
</li>
</ul>
<p><a id="orgbb80270"></a></p>
<h3 id="3-5-4-Serial-Old收集器"><a href="#3-5-4-Serial-Old收集器" class="headerlink" title="3.5.4 Serial Old收集器"></a>3.5.4 Serial Old收集器</h3><ul>
<li><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法</p>
</li>
<li><p>这个收集器的主要意义也是在于给Client模式下的虚拟机使用</p>
</li>
<li><p>如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
</li>
</ul>
<p><a id="org182d65d"></a></p>
<h3 id="3-5-5-Parallel-Old收集器"><a href="#3-5-5-Parallel-Old收集器" class="headerlink" title="3.5.5 Parallel Old收集器"></a>3.5.5 Parallel Old收集器</h3><ul>
<li>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</li>
</ul>
<p><a id="org5ef3b7c"></a></p>
<h3 id="3-5-6-CMS收集器"><a href="#3-5-6-CMS收集器" class="headerlink" title="3.5.6 CMS收集器"></a>3.5.6 CMS收集器</h3><ul>
<li><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
</li>
<li><p>CMS收集器是基于“标记—清除”算法实现的</p>
</li>
<li><p>整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
</li>
<li><p>初始标记、重新标记这两个步骤仍然需要“Stop The World”。</p>
</li>
<li><p>CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，Sun公司的一些官方文档中也称之为并发低停顿收集器（Concurrent Low Pause Collector）</p>
</li>
<li><p>它有以下3个明显的缺点：</p>
<ul>
<li>CMS收集器对CPU资源非常敏感。</li>
<li>CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在JDK 1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
<li>还有最后一个缺点，在本节开头说过，CMS是一款基于“标记—清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会有大量空间碎片产生。</li>
</ul>
</li>
</ul>
<p><a id="org392406e"></a></p>
<h3 id="3-5-7-G1收集器"><a href="#3-5-7-G1收集器" class="headerlink" title="3.5.7 G1收集器"></a>3.5.7 G1收集器</h3><ul>
<li><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一</p>
</li>
<li><p>G1是一款面向服务端应用的垃圾收集器。</p>
</li>
<li><p>JDK9发布之后，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。</p>
</li>
<li><p>使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了</p>
</li>
<li><p>每个Region都可以根据需求，扮演新生代的Eden空间、Survivor空间，或者老年代空间。</p>
</li>
<li><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。G1认为超过一个Region容量一半的对象即可判定为大对象，超过Region容量的超级大对象就会被存在N各连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来看待。</p>
</li>
<li><p>G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）</p>
</li>
<li><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
</li>
<li><p>相比CMS，G1的有点很多，可以指定最大停顿时间，分Region的内存布局、按收益动态确定回收集，同时采用了标记-整理和局部标记-复制算法，能有利于垃圾收集完成后提供规整的可用内存。这种特性有利于程序长时间运行。</p>
</li>
<li><p>相比于CMS的劣势，需要更多内存来记录每个Region中的卡表。在执行负载角度上，G1因为对写屏障需要花费更多的运算资源。</p>
</li>
<li><p>小内存应用上CMS的表现大概率仍然要优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB-8GB之见。</p>
</li>
</ul>
<p><a id="org3080f56"></a></p>
<h1 id="第5章-调优案例分析与实战"><a href="#第5章-调优案例分析与实战" class="headerlink" title="第5章 调优案例分析与实战"></a>第5章 调优案例分析与实战</h1><ul>
<li>在高性能硬件上部署程序，目前主要有两种方式：<ul>
<li>通过64位JDK来使用大内存。</li>
<li>使用若干个32位虚拟机建立逻辑集群来利用硬件资源。</li>
</ul>
</li>
</ul>
<p><a id="org7823b00"></a></p>
<h1 id="第6章-类文件结构"><a href="#第6章-类文件结构" class="headerlink" title="第6章 类文件结构"></a>第6章 类文件结构</h1><ul>
<li>代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。</li>
</ul>
<p><a id="orgfc0ac26"></a></p>
<h1 id="第7章-虚拟机类加载机制"><a href="#第7章-虚拟机类加载机制" class="headerlink" title="第7章 虚拟机类加载机制"></a>第7章 虚拟机类加载机制</h1><p><a id="org3ad9b55"></a></p>
<h2 id="7-2-类加载的时机"><a href="#7-2-类加载的时机" class="headerlink" title="7.2 类加载的时机"></a>7.2 类加载的时机</h2><ul>
<li>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。</li>
</ul>
<img src="/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" class="" title="类的生命周期">

<ul>
<li><p>加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定</p>
</li>
<li><p>但是对于初始化阶段，虚拟机规范则是严格规定了有且只有5种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li>
<li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF<sub>getStatic</sub>、REF<sub>putStatic</sub>、REF<sub>invokeStatic的方法句柄</sub>，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
</li>
<li><p>除此之外，所有引用类的方式都不会触发初始化，称为被动引用。</p>
</li>
<li><p>对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。</p>
</li>
<li><p>接口与类真正有所区别的是前面讲述的5种“有且仅有”需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>
</li>
</ul>
<p><a id="org7812a0b"></a></p>
<h2 id="7-3-类加载的过程"><a href="#7-3-类加载的过程" class="headerlink" title="7.3 类加载的过程"></a>7.3 类加载的过程</h2><p><a id="org0b5f36d"></a></p>
<h3 id="7-3-1-加载"><a href="#7-3-1-加载" class="headerlink" title="7.3.1 加载"></a>7.3.1 加载</h3><ul>
<li><p>“加载”是“类加载”（Class Loading）过程的一个阶段，希望读者没有混淆这两个看起来很相似的名词</p>
</li>
<li><p>在加载阶段，虚拟机需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
</li>
</ul>
<p><a id="org6f6cd99"></a></p>
<h3 id="7-3-2-验证"><a href="#7-3-2-验证" class="headerlink" title="7.3.2 验证"></a>7.3.2 验证</h3><ul>
<li>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<ol>
<li>文件格式验证</li>
<li>元数据验证</li>
<li>字节码验证</li>
<li>符号引用验证</li>
</ol>
</li>
</ul>
<p><a id="org587518b"></a></p>
<h3 id="7-3-3-准备"><a href="#7-3-3-准备" class="headerlink" title="7.3.3 准备"></a>7.3.3 准备</h3><ul>
<li><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。(指静态变量，被static修饰的变量）</p>
</li>
<li><p>实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p>
</li>
</ul>
<p><a id="org6aefb0c"></a></p>
<h3 id="7-3-4-解析"><a href="#7-3-4-解析" class="headerlink" title="7.3.4 解析"></a>7.3.4 解析</h3><ul>
<li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程</li>
</ul>
<p><a id="org9b44106"></a></p>
<h3 id="7-3-5-初始化"><a href="#7-3-5-初始化" class="headerlink" title="7.3.5 初始化"></a>7.3.5 初始化</h3><ul>
<li><p>类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）。</p>
</li>
<li><p>在准备阶段，变量已经赋过一次系统要求的初始值</p>
</li>
<li><p>初始化阶段，则根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。</p>
</li>
<li><p>我们先看一下&lt;clinit&gt;()方法执行过程中一些可能会影响程序运行行为的特点和细节，这部分相对更贴近于普通的程序开发人员。</p>
<ul>
<li>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问，如代码清单7-5中的例子所示。</li>
<li>&lt;clinit&gt;()方法与类的构造函数（或者说实例构造器&lt;init&gt;()方法）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()方法已经执行完毕。因此在虚拟机中第一个被执行的&lt;clinit&gt;()方法的类肯定是java.lang.Object。</li>
<li>由于父类的&lt;clinit&gt;()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如在代码清单7-6中，字段B的值将会是2而不是1。</li>
<li>&lt;clinit&gt;()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;()方法。</li>
<li>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clinit&gt;()方法。但接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。</li>
<li>虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个进程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</li>
</ul>
</li>
</ul>
<p><a id="org3f680a8"></a></p>
<h2 id="7-4-类加载器"><a href="#7-4-类加载器" class="headerlink" title="7.4 类加载器"></a>7.4 类加载器</h2><ul>
<li><p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p>
</li>
<li><p>虽然目前Java Applet技术基本上已经“死掉”，但类加载器却在类层次划分、OSGi、热部署、代码加密等领域大放异彩，成为了Java技术体系中一块重要的基石，可谓是失之桑榆，收之东隅。</p>
</li>
</ul>
<p><a id="orgdb9534f"></a></p>
<h3 id="7-4-1-类与类加载器"><a href="#7-4-1-类与类加载器" class="headerlink" title="7.4.1 类与类加载器"></a>7.4.1 类与类加载器</h3><ul>
<li><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。</p>
</li>
<li><p>比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
</li>
<li><p>如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果，代码清单7-8中演示了不同的类加载器对instanceof关键字运算的结果的影响。</p>
</li>
</ul>
<p><a id="orgfeccbe1"></a></p>
<h3 id="7-4-2-双亲委派模型"><a href="#7-4-2-双亲委派模型" class="headerlink" title="7.4.2 双亲委派模型"></a>7.4.2 双亲委派模型</h3><ul>
<li><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p>
</li>
<li><p>绝大部分Java程序都会使用到以下3种系统提供的类加载器。</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：前面已经介绍过，这个类将器负责将存放在&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，</li>
<li>扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;AVA_HOM&gt;\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$App-ClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。</li>
</ul>
</li>
<li><p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p>
</li>
</ul>
<img src="/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.png" class="" title="类加载器双亲委派模型">

<ul>
<li><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。</p>
</li>
<li><p>双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
</li>
<li><p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。</p>
</li>
</ul>
<p><a id="orgaaa83a7"></a></p>
<h3 id="7-4-3-破坏双亲委派模型"><a href="#7-4-3-破坏双亲委派模型" class="headerlink" title="7.4.3 破坏双亲委派模型"></a>7.4.3 破坏双亲委派模型</h3><ul>
<li><p>上文提到过双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式。</p>
</li>
<li><p>到目前为止，双亲委派模型主要出现过3较大规模的“被破坏”情况。</p>
</li>
<li><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前</p>
</li>
<li><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？</p>
</li>
<li><p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoaser()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
</li>
<li><p>JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则</p>
</li>
<li><p>Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI、JDBC、JCE、JAXB和JBI等。</p>
</li>
<li><p>双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是当前一些非常“热门”的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等</p>
</li>
<li><p>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构，当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<ol>
<li>将以java.*开头的类委派给父类加载器加载。</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载。</li>
<li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。</li>
<li>否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</li>
<li>否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。</li>
<li>否则，类查找失败。</li>
</ol>
<img src="/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/OSGi%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F.png" class="" title="OSGi类加载顺序"></li>
</ul>
<p><a id="org814c1d8"></a></p>
<h1 id="第8章-虚拟机字节码执行引擎"><a href="#第8章-虚拟机字节码执行引擎" class="headerlink" title="第8章 虚拟机字节码执行引擎"></a>第8章 虚拟机字节码执行引擎</h1><p><a id="org266de21"></a></p>
<h2 id="8-2-运行时栈帧结构"><a href="#8-2-运行时栈帧结构" class="headerlink" title="8.2 运行时栈帧结构"></a>8.2 运行时栈帧结构</h2><p><a id="org256e938"></a></p>
<h3 id="8-2-1-局部变量表"><a href="#8-2-1-局部变量表" class="headerlink" title="8.2.1 局部变量表"></a>8.2.1 局部变量表</h3><ul>
<li>但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句int a&#x3D;0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。</li>
</ul>
<p><a id="org743a54e"></a></p>
<h2 id="8-3-方法调用"><a href="#8-3-方法调用" class="headerlink" title="8.3 方法调用"></a>8.3 方法调用</h2><p><a id="orgbb8d3f1"></a></p>
<h3 id="8-3-1-解析"><a href="#8-3-1-解析" class="headerlink" title="8.3.1 解析"></a>8.3.1 解析</h3><ul>
<li><p>换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。</p>
</li>
<li><p>在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。</p>
</li>
</ul>
<p><a id="org635134f"></a></p>
<h1 id="第12章-Java内存模型与线程"><a href="#第12章-Java内存模型与线程" class="headerlink" title="第12章 Java内存模型与线程"></a>第12章 Java内存模型与线程</h1><p><a id="orgcbabd74"></a></p>
<h2 id="12-2-硬件的效率与一致性"><a href="#12-2-硬件的效率与一致性" class="headerlink" title="12.2 硬件的效率与一致性"></a>12.2 硬件的效率与一致性</h2><ul>
<li>为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有类似的指令重排序（Instruction Reorder）优化。</li>
</ul>
<p><a id="orga0caaaf"></a></p>
<h2 id="12-3-Java内存模型"><a href="#12-3-Java内存模型" class="headerlink" title="12.3 Java内存模型"></a>12.3 Java内存模型</h2><p><a id="orge5900d1"></a></p>
<h3 id="12-3-1-主内存与工作内存"><a href="#12-3-1-主内存与工作内存" class="headerlink" title="12.3.1 主内存与工作内存"></a>12.3.1 主内存与工作内存</h3><ul>
<li><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p>
</li>
<li><p>但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p>
</li>
<li><p>线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。</p>
</li>
</ul>
<p><a id="orgb0da347"></a></p>
<h3 id="12-3-2-内存间交互操作"><a href="#12-3-2-内存间交互操作" class="headerlink" title="12.3.2 内存间交互操作"></a>12.3.2 内存间交互操作</h3><ul>
<li><p>Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的（对于double和long类型的变量来说，load、store、read和write操作在某些平台上允许有例外，这个问题在12.3.4节再讲）。</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
</li>
<li><p>除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</p>
<ul>
<li>不允许read和load、store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量，换句话说，就是对一个变量实施use、store操作之前，必须先执行过了assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
</li>
</ul>
<p><a id="org8efa1d0"></a></p>
<h3 id="12-3-3-对于volatile型变量的特殊规则"><a href="#12-3-3-对于volatile型变量的特殊规则" class="headerlink" title="12.3.3 对于volatile型变量的特殊规则"></a>12.3.3 对于volatile型变量的特殊规则</h3><ul>
<li><p>当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。</p>
</li>
<li><p>volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是Java里面的运算并非原子操作，导致volatile变量的运算在并发下一样是不安全的</p>
</li>
<li><p>由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性。</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ul>
</li>
<li><p>使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。</p>
</li>
<li><p>关键变化在于有volatile修饰的变量，赋值后（前面mov %eax，0x150（%esi）这句便是赋值操作）多执行了一个“lock addl $0x0，（%esp）”操作，这个操作相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。</p>
</li>
<li><p>因此我们在编写代码时一般不需要把用到的long和double变量专门声明为volatile。</p>
</li>
</ul>
<p><a id="org691cfeb"></a></p>
<h3 id="12-3-5-原子性、可见性与有序性"><a href="#12-3-5-原子性、可见性与有序性" class="headerlink" title="12.3.5 原子性、可见性与有序性"></a>12.3.5 原子性、可见性与有序性</h3><ul>
<li><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个特征来建立的</p>
</li>
<li><p>原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问读写是具备原子性的（例外就是long和double的非原子性协定，读者只要知道这件事情就可以了，无须太过在意这些几乎不会发生的例外情况）。</p>
</li>
<li><p>可见性（Visibility）：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。</p>
</li>
<li><p>有序性（Ordering）：Java内存模型的有序性在前面讲解volatile时也详细地讨论过了，Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p>
</li>
</ul>
<p><a id="org390f025"></a></p>
<h3 id="12-3-6-先行发生原则"><a href="#12-3-6-先行发生原则" class="headerlink" title="12.3.6 先行发生原则"></a>12.3.6 先行发生原则</h3><ul>
<li><p>如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。</p>
<ul>
<li>程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li>
<li>volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li>
<li>线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。</li>
<li>对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。</li>
<li>传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
</li>
<li><p>时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。</p>
</li>
</ul>
<p><a id="orgd7ac1c1"></a></p>
<h2 id="12-4-Java与线程"><a href="#12-4-Java与线程" class="headerlink" title="12.4 Java与线程"></a>12.4 Java与线程</h2><p><a id="org0e698b7"></a></p>
<h3 id="12-4-2-Java线程调度"><a href="#12-4-2-Java线程调度" class="headerlink" title="12.4.2 Java线程调度"></a>12.4.2 Java线程调度</h3><ul>
<li><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度（Cooperative Threads-Scheduling）和抢占式线程调度（Preemptive Threads-Scheduling）。</p>
</li>
<li><p>如果使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。</p>
</li>
<li><p>它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</p>
</li>
<li><p>如果使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定（在Java中，Thread.yield()可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）。</p>
</li>
<li><p>Java使用的线程调度方式就是抢占式调度-。</p>
</li>
<li><p>Java语言一共设置了10个级别的线程优先级（Thread.MIN<sub>PRIORITY至Thread</sub>. MAX<sub>PRIORITY</sub>），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p>
</li>
</ul>
<p><a id="orgb7c5561"></a></p>
<h3 id="12-4-3-状态转换"><a href="#12-4-3-状态转换" class="headerlink" title="12.4.3 状态转换"></a>12.4.3 状态转换</h3><ul>
<li>Java语言定义了6种线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态，这6种状态分别如下。<ul>
<li>新建（New）：创建后尚未启动的线程处于这种状态。</li>
<li>运行（Runable）：Runable包括了操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为它分配执行时间。</li>
<li>无限期等待（Waiting）：处于这种状态的线程不会被分配CPU执行时间，它们要等待被其他线程显式地唤醒。以下方法会让线程陷入无限期的等待状态：<ul>
<li>没有设置Timeout参数的Object.wait()方法。</li>
<li>没有设置Timeout参数的Thread.join()方法。</li>
<li>LockSupport.park()方法。</li>
</ul>
</li>
<li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式地唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul>
<li>Thread.sleep()方法。</li>
<li>设置了Timeout参数的Object.wait()方法。</li>
<li>设置了Timeout参数的Thread.join()方法。</li>
<li>LockSupport.parkNanos()方法。</li>
<li>LockSupport.parkUntil()方法。</li>
</ul>
</li>
<li>阻塞（Blocked）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：“阻塞状态”在等待着获取到一个排他锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
<li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li>
</ul>
</li>
</ul>
<img src="/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png" class="" title="线程状态转换关系">


<p><a id="orgc21f1eb"></a></p>
<h1 id="第13章-线程安全与锁优化"><a href="#第13章-线程安全与锁优化" class="headerlink" title="第13章 线程安全与锁优化"></a>第13章 线程安全与锁优化</h1><p><a id="org49130fe"></a></p>
<h2 id="13-2-线程安全"><a href="#13-2-线程安全" class="headerlink" title="13.2 线程安全"></a>13.2 线程安全</h2><ul>
<li><p>“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的”。</p>
</li>
<li><p>代码本身封装了所有必要的正确性保障手段（如互斥同步等），令调用者无须关心多线程的问题，更无须自己采取任何措施来保证多线程的正确调用。</p>
</li>
</ul>
<p><a id="orga374a04"></a></p>
<h3 id="13-2-1-Java语言中的线程安全"><a href="#13-2-1-Java语言中的线程安全" class="headerlink" title="13.2.1 Java语言中的线程安全"></a>13.2.1 Java语言中的线程安全</h3><ul>
<li>我们可以将Java语言中各种操作共享的数据分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。<ol>
<li>不可变</li>
<li>绝对线程安全<ul>
<li>绝对的线程安全完全满足Brian Goetz给出的线程安全的定义，这个定义其实是很严格的，一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。</li>
</ul>
</li>
<li>相对线程安全<ul>
<li>相对的线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</li>
</ul>
</li>
<li>线程兼容<ul>
<li>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。</li>
</ul>
</li>
<li>线程对立<ul>
<li>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。</li>
</ul>
</li>
</ol>
</li>
</ul>
<p><a id="org9f3e48a"></a></p>
<h3 id="13-2-2-线程安全的实现方法"><a href="#13-2-2-线程安全的实现方法" class="headerlink" title="13.2.2 线程安全的实现方法"></a>13.2.2 线程安全的实现方法</h3><ul>
<li><p>1.互斥同步</p>
</li>
<li><p>互斥同步（Mutual Exclusion &amp; Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。</p>
</li>
<li><p>在Java中，最基本的互斥同步手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。</p>
</li>
<li><p>根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p>
</li>
<li><p>有两点是需要特别注意的。首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。</p>
</li>
<li><p>，Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块（如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。</p>
</li>
<li><p>除了synchronized之外，我们还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁（ReentrantLock）来实现同步</p>
</li>
<li><p>不过，相比synchronized，ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件。</p>
<ul>
<li>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。</li>
<li>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。</li>
</ul>
</li>
<li><p>2.非阻塞同步</p>
</li>
<li><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。</p>
</li>
<li><p>随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p>
</li>
<li><p>硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：</p>
<ul>
<li>测试并设置（Test-and-Set）。</li>
<li>获取并增加（Fetch-and-Increment）。</li>
<li>交换（Swap）。</li>
<li>比较并交换（Compare-and-Swap，下文称CAS）。</li>
<li>加载链接&#x2F;条件存储（Load-Linked&#x2F;Store-Conditional，下文称LL&#x2F;SC）。</li>
</ul>
</li>
<li><p>CAS指令需要有3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。</p>
</li>
<li><p>3.无同步方案</p>
</li>
<li><p>如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，笔者简单地介绍其中的两类。</p>
</li>
<li><p>可重入代码（Reentrant Code）：这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p>
</li>
<li><p>线程本地存储（Thread Local Storage）：如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p>
</li>
<li><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</p>
</li>
<li><p>每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</p>
</li>
</ul>
<p><a id="orgb6d00f5"></a></p>
<h2 id="13-3-锁优化"><a href="#13-3-锁优化" class="headerlink" title="13.3 锁优化"></a>13.3 锁优化</h2><p><a id="org42599a8"></a></p>
<h3 id="13-3-1-自旋锁与自适应自旋"><a href="#13-3-1-自旋锁与自适应自旋" class="headerlink" title="13.3.1 自旋锁与自适应自旋"></a>13.3.1 自旋锁与自适应自旋</h3><ul>
<li><p>如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</p>
</li>
<li><p>如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。</p>
</li>
<li><p>在JDK 1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</p>
</li>
</ul>
<p><a id="org2b20faf"></a></p>
<h3 id="13-3-2-锁消除"><a href="#13-3-2-锁消除" class="headerlink" title="13.3.2 锁消除"></a>13.3.2 锁消除</h3><ul>
<li>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持（第11章已经讲解过逃逸分析技术），如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</li>
</ul>
<p><a id="org0f30bcc"></a></p>
<h3 id="13-3-3-锁粗化"><a href="#13-3-3-锁粗化" class="headerlink" title="13.3.3 锁粗化"></a>13.3.3 锁粗化</h3><ul>
<li>但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。代码清单13-7中连续的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以代码清单13-7为例，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了。</li>
</ul>
<p><a id="orgd87bc65"></a></p>
<h3 id="13-3-4-轻量级锁"><a href="#13-3-4-轻量级锁" class="headerlink" title="13.3.4 轻量级锁"></a>13.3.4 轻量级锁</h3><ul>
<li><p>轻量级锁是JDK 1.6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。</p>
</li>
<li><p>轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。</p>
</li>
</ul>
<p><a id="org7735aa9"></a></p>
<h3 id="13-3-5-偏向锁"><a href="#13-3-5-偏向锁" class="headerlink" title="13.3.5 偏向锁"></a>13.3.5 偏向锁</h3><ul>
<li><p>偏向锁也是JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p>
</li>
<li><p>假设当前虚拟机启用了偏向锁（启用参数-XX:+UseBiasedLocking，这是JDK 1.6的默认值），那么，当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设为“01”，即偏向模式。</p>
</li>
<li><p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向（Revoke Bias）后恢复到未锁定（标志位为“01”）或轻量级锁定（标志位为“00”）的状态，后续的同步操作就如上面介绍的轻量级锁那样执行。</p>
</li>
</ul>
<img src="/2022/12/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC%E4%B8%89%E7%89%88%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/%E9%94%81%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8C%96.png" class="" title="锁的状态转化">


    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
              <a href="/tags/Jvm/" rel="tag"><i class="fa fa-tag"></i> Jvm</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/12/08/%E7%94%A8docker%E6%90%AD%E5%BB%BAredis%E9%9B%86%E7%BE%A4/" rel="prev" title="Docker搭建redis集群">
                  <i class="fa fa-angle-left"></i> Docker搭建redis集群
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/01/10/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/" rel="next" title="微信读书《人月神话》笔记导出">
                  微信读书《人月神话》笔记导出 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yellow</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">122k</span>
  </span>
</div>

    </div>
  </footer>

    
​
  <script color="0, 0, 255" 
          opacity="0.5" 
          zIndex="-1" 
          count="120" 
          src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js">
  </script>
​
  

  

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




 

<script>
  var OriginTitile = document.title;
  var titleTime;
  //换网站的logo
  function selfSetIcon(url){
        var links = document.getElementsByTagName('link') 
        for (var i = 0; i < links.length; i++) { 
            var link = links[i]
            var rel = link.rel; 
            var count = 0;
            rel = rel.toLowerCase(); 
            if (rel.indexOf('icon') == 0) { 
                count++;
                link.href = url;
                if(count == 2)
                    break;
            }
        }
    }
  
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(●—●)喔噢，崩溃了~|" + OriginTitile;
      // selfSetIcon("");
      clearTimeout(titleTime);
    } else {
      // selfSetIcon("/images/favicon-32x32-next.png");
      document.title = "φ(>ω<*) 咦！又好了！|" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
        
      }, 2000);
    }
  });
  
</script>

</body>
</html>
<script type="text/javascript" src="/js/src/click.js"></script>