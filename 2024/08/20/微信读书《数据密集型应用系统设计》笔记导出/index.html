<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"rosinanteplusssss.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="数据密集型应用系统设计">
<meta property="og:type" content="article">
<meta property="og:title" content="微信读书《数据密集型应用系统设计》笔记导出">
<meta property="og:url" content="https://rosinanteplusssss.github.io/2024/08/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/index.html">
<meta property="og:site_name" content="日復一日">
<meta property="og:description" content="数据密集型应用系统设计">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-08-20T05:49:21.000Z">
<meta property="article:modified_time" content="2024-10-11T03:29:06.327Z">
<meta property="article:author" content="Yellow">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="读书">
<meta property="article:tag" content="微信读书">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://rosinanteplusssss.github.io/2024/08/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://rosinanteplusssss.github.io/2024/08/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/","path":"2024/08/20/微信读书《数据密集型应用系统设计》笔记导出/","title":"微信读书《数据密集型应用系统设计》笔记导出"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>微信读书《数据密集型应用系统设计》笔记导出 | 日復一日</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">日復一日</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">當一個堅持的人</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Table-of-Contents"><span class="nav-number">1.</span> <span class="nav-text">Table of Contents</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="nav-number">2.</span> <span class="nav-text">数据系统的基石</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E3%80%81%E5%8F%AF%E4%BC%B8%E7%BC%A9%E6%80%A7%E3%80%81%E5%8F%AF%E7%BB%B4%E6%8A%A4%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">可靠性、可伸缩性、可维护性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="nav-number">2.2.</span> <span class="nav-text">数据模型与查询语言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2"><span class="nav-number">2.3.</span> <span class="nav-text">存储与检索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E4%B8%8E%E6%BC%94%E5%8C%96"><span class="nav-number">2.4.</span> <span class="nav-text">编码与演化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE"><span class="nav-number">3.</span> <span class="nav-text">分布式数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6"><span class="nav-number">3.1.</span> <span class="nav-text">复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="nav-number">3.1.1.</span> <span class="nav-text">同步复制与异步复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BE%E7%BD%AE%E6%96%B0%E4%BB%8E%E5%BA%93"><span class="nav-number">3.1.2.</span> <span class="nav-text">设置新从库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%BA%93%E5%A4%B1%E6%95%88%EF%BC%9A%E6%95%85%E9%9A%9C%E5%88%87%E6%8D%A2"><span class="nav-number">3.1.3.</span> <span class="nav-text">主库失效：故障切换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E6%97%A5%E5%BF%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.4.</span> <span class="nav-text">复制日志的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%B7%B1%E4%B9%8B%E5%86%99"><span class="nav-number">3.1.5.</span> <span class="nav-text">读己之写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E8%B0%83%E8%AF%BB"><span class="nav-number">3.1.6.</span> <span class="nav-text">单调读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E5%89%8D%E7%BC%80%E8%AF%BB"><span class="nav-number">3.1.7.</span> <span class="nav-text">一致前缀读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E5%88%B6%E5%BB%B6%E8%BF%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">3.1.8.</span> <span class="nav-text">复制延迟的解决方案</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="nav-number">3.1.9.</span> <span class="nav-text">多主复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.10.</span> <span class="nav-text">多主复制的应用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%BB%B4%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83"><span class="nav-number">3.1.11.</span> <span class="nav-text">运维多个数据中心</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B6%E6%95%9B%E8%87%B3%E4%B8%80%E8%87%B4%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">3.1.12.</span> <span class="nav-text">收敛至一致的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B8%BB%E5%A4%8D%E5%88%B6%E6%8B%93%E6%89%91"><span class="nav-number">3.1.13.</span> <span class="nav-text">多主复制拓扑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%A0%E4%B8%BB%E5%A4%8D%E5%88%B6"><span class="nav-number">3.1.14.</span> <span class="nav-text">无主复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BD%93%E8%8A%82%E7%82%B9%E6%95%85%E9%9A%9C%E6%97%B6%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.1.15.</span> <span class="nav-text">当节点故障时写入数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E4%BF%AE%E5%A4%8D%E5%92%8C%E5%8F%8D%E7%86%B5"><span class="nav-number">3.1.16.</span> <span class="nav-text">读修复和反熵</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E7%9A%84%E6%B3%95%E5%AE%9A%E4%BA%BA%E6%95%B0"><span class="nav-number">3.1.17.</span> <span class="nav-text">读写的法定人数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%95%E5%AE%9A%E4%BA%BA%E6%95%B0%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="nav-number">3.1.18.</span> <span class="nav-text">法定人数一致性的局限性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7%E9%99%88%E6%97%A7%E5%BA%A6"><span class="nav-number">3.1.19.</span> <span class="nav-text">监控陈旧度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%BD%E6%9D%BE%E7%9A%84%E6%B3%95%E5%AE%9A%E4%BA%BA%E6%95%B0%E4%B8%8E%E6%8F%90%E7%A4%BA%E7%A7%BB%E4%BA%A4"><span class="nav-number">3.1.20.</span> <span class="nav-text">宽松的法定人数与提示移交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E5%86%99%E5%85%A5%E8%83%9C%E5%88%A9%EF%BC%88%E4%B8%A2%E5%BC%83%E5%B9%B6%E5%8F%91%E5%86%99%E5%85%A5%EF%BC%89"><span class="nav-number">3.1.21.</span> <span class="nav-text">最后写入胜利（丢弃并发写入）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9C%E6%AD%A4%E5%89%8D%E5%8F%91%E7%94%9F%E2%80%9D%E7%9A%84%E5%85%B3%E7%B3%BB%E5%92%8C%E5%B9%B6%E5%8F%91"><span class="nav-number">3.1.22.</span> <span class="nav-text">“此前发生”的关系和并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%80%A7%EF%BC%8C%E6%97%B6%E9%97%B4%E5%92%8C%E7%9B%B8%E5%AF%B9%E6%80%A7"><span class="nav-number">3.1.23.</span> <span class="nav-text">并发性，时间和相对性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%8C%BA"><span class="nav-number">3.2.</span> <span class="nav-text">分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%86%E5%8C%BA"><span class="nav-number">3.2.1.</span> <span class="nav-text">键值数据的分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B9%E6%8D%AE%E9%94%AE%E7%9A%84%E6%95%A3%E5%88%97%E5%88%86%E5%8C%BA"><span class="nav-number">3.2.2.</span> <span class="nav-text">根据键的散列分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E8%BD%BD%E5%81%8F%E6%96%9C%E4%B8%8E%E7%83%AD%E7%82%B9%E6%B6%88%E9%99%A4"><span class="nav-number">3.2.3.</span> <span class="nav-text">负载偏斜与热点消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E4%B8%8E%E6%AC%A1%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.4.</span> <span class="nav-text">分区与次级索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%96%87%E6%A1%A3%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E5%88%86%E5%8C%BA"><span class="nav-number">3.2.5.</span> <span class="nav-text">基于文档的二级索引进行分区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E5%86%8D%E5%B9%B3%E8%A1%A1"><span class="nav-number">3.2.6.</span> <span class="nav-text">分区再平衡</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E5%B9%B3%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="nav-number">3.2.7.</span> <span class="nav-text">再平衡策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1"><span class="nav-number">3.2.8.</span> <span class="nav-text">请求路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-number">3.2.9.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1"><span class="nav-number">3.3.</span> <span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ACID%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">ACID的含义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%AF%B9%E8%B1%A1%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9C%80%E6%B1%82"><span class="nav-number">3.3.2.</span> <span class="nav-text">多对象事务的需求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%E5%92%8C%E7%BB%88%E6%AD%A2"><span class="nav-number">3.3.3.</span> <span class="nav-text">处理错误和终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%B1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.3.4.</span> <span class="nav-text">弱隔离级别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number">3.3.5.</span> <span class="nav-text">读已提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="nav-number">3.3.6.</span> <span class="nav-text">实现读已提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB%E5%92%8C%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">3.3.7.</span> <span class="nav-text">快照隔离和可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E5%BF%AB%E7%85%A7%E9%9A%94%E7%A6%BB"><span class="nav-number">3.3.8.</span> <span class="nav-text">实现快照隔离</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3%E5%92%8C%E5%A4%8D%E5%88%B6"><span class="nav-number">3.3.9.</span> <span class="nav-text">冲突解决和复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%81%8F%E5%B7%AE%E7%9A%84%E7%89%B9%E5%BE%81"><span class="nav-number">3.3.10.</span> <span class="nav-text">写偏差的特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="nav-number">3.3.11.</span> <span class="nav-text">可串行化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81%E5%AE%9A"><span class="nav-number">3.3.12.</span> <span class="nav-text">两阶段锁定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="nav-number">3.3.13.</span> <span class="nav-text">实现两阶段锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E9%94%81"><span class="nav-number">3.3.14.</span> <span class="nav-text">索引范围锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%82%B2%E8%A7%82%E4%B8%8E%E4%B9%90%E8%A7%82%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="nav-number">3.3.15.</span> <span class="nav-text">悲观与乐观的并发控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-1"><span class="nav-number">3.3.16.</span> <span class="nav-text">本章小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%BA%BB%E7%83%A6"><span class="nav-number">3.4.</span> <span class="nav-text">分布式系统的麻烦</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E4%B8%8E%E5%85%B1%E8%AF%86"><span class="nav-number">3.5.</span> <span class="nav-text">一致性与共识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E8%AF%86%E7%9A%84%E4%B8%8D%E5%8F%AF%E8%83%BD%E6%80%A7"><span class="nav-number">3.5.1.</span> <span class="nav-text">共识的不可能性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E7%AE%80%E4%BB%8B"><span class="nav-number">3.5.2.</span> <span class="nav-text">两阶段提交简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="nav-number">3.5.3.</span> <span class="nav-text">三阶段提交</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#XA%E4%BA%8B%E5%8A%A1"><span class="nav-number">3.5.4.</span> <span class="nav-text">XA事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%80%E7%96%91%E6%97%B6%E6%8C%81%E6%9C%89%E9%94%81"><span class="nav-number">3.5.5.</span> <span class="nav-text">怀疑时持有锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%8D%8F%E8%B0%83%E8%80%85%E6%95%85%E9%9A%9C%E4%B8%AD%E6%81%A2%E5%A4%8D"><span class="nav-number">3.5.6.</span> <span class="nav-text">从协调者故障中恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E5%85%B1%E8%AF%86"><span class="nav-number">3.5.7.</span> <span class="nav-text">容错共识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%92%8C%E5%85%A8%E5%BA%8F%E5%B9%BF%E6%92%AD"><span class="nav-number">3.5.8.</span> <span class="nav-text">共识算法和全序广播</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%A2%86%E5%AF%BC%E8%80%85%E5%A4%8D%E5%88%B6%E4%B8%8E%E5%85%B1%E8%AF%86"><span class="nav-number">3.5.9.</span> <span class="nav-text">单领导者复制与共识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E5%B0%8F%E7%BB%93-2"><span class="nav-number">3.5.10.</span> <span class="nav-text">本章小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%A1%8D%E7%94%9F%E6%95%B0%E6%8D%AE"><span class="nav-number">4.</span> <span class="nav-text">衍生数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E5%A4%84%E7%90%86"><span class="nav-number">4.1.</span> <span class="nav-text">流处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%9C%AA%E6%9D%A5"><span class="nav-number">4.2.</span> <span class="nav-text">数据系统的未来</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda%E6%9E%B6%E6%9E%84"><span class="nav-number">4.2.1.</span> <span class="nav-text">Lambda架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%8B%86%E7%B3%BB%E7%BB%9Fvs%E9%9B%86%E6%88%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.2.2.</span> <span class="nav-text">分拆系统vs集成系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%BA%94%E7%94%A8%E7%AB%AF%E5%88%B0%E7%AB%AF%E6%80%9D%E8%80%83"><span class="nav-number">4.2.3.</span> <span class="nav-text">在数据系统中应用端到端思考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%88%B6%E7%BA%A6%E6%9D%9F"><span class="nav-number">4.2.4.</span> <span class="nav-text">强制约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F%E9%9C%80%E8%A6%81%E8%BE%BE%E6%88%90%E5%85%B1%E8%AF%86"><span class="nav-number">4.2.5.</span> <span class="nav-text">唯一性约束需要达成共识</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8A%E6%97%B6%E6%80%A7%E4%B8%8E%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">4.2.6.</span> <span class="nav-text">及时性与完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%BD%E6%9D%BE%E5%9C%B0%E8%A7%A3%E9%87%8A%E7%BA%A6%E6%9D%9F"><span class="nav-number">4.2.7.</span> <span class="nav-text">宽松地解释约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9A%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BA%8B%E6%83%85"><span class="nav-number">4.2.8.</span> <span class="nav-text">做正确的事情</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yellow"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Yellow</p>
  <div class="site-description" itemprop="description">碼農</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/rosinanteplusssss" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;rosinanteplusssss" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:yellowdingjr@gmail.com" title="E-Mail → mailto:yellowdingjr@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://rosinanteplusssss.github.io/2024/08/20/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E3%80%8A%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0%E5%AF%BC%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Yellow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="日復一日">
      <meta itemprop="description" content="碼農">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="微信读书《数据密集型应用系统设计》笔记导出 | 日復一日">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          微信读书《数据密集型应用系统设计》笔记导出
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-20 13:49:21" itemprop="dateCreated datePublished" datetime="2024-08-20T13:49:21+08:00">2024-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-10-11 11:29:06" itemprop="dateModified" datetime="2024-10-11T11:29:06+08:00">2024-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">读书</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>41 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>数据密集型应用系统设计</p>
<span id="more"></span>

<h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ol>
<li><a href="#org5114818">数据系统的基石</a><ol>
<li><a href="#org6dee7c9">可靠性、可伸缩性、可维护性</a></li>
<li><a href="#orgf3822ce">数据模型与查询语言</a></li>
<li><a href="#orgc307b6e">存储与检索</a></li>
<li><a href="#org06331d9">编码与演化</a></li>
</ol>
</li>
<li><a href="#org54fbf05">分布式数据</a><ol>
<li><a href="#orgf82f0d5">复制</a><ol>
<li><a href="#org7c5e7b9">同步复制与异步复制</a></li>
<li><a href="#orgcfe55f0">设置新从库</a></li>
<li><a href="#org4a94680">主库失效：故障切换</a></li>
<li><a href="#org5929a85">复制日志的实现</a></li>
<li><a href="#org68cb07c">读己之写</a></li>
<li><a href="#orga49fd85">单调读</a></li>
<li><a href="#orgd9579ac">一致前缀读</a></li>
<li><a href="#org89f52a8">复制延迟的解决方案</a></li>
<li><a href="#orgc63650e">多主复制</a></li>
<li><a href="#org4eb85fb">多主复制的应用场景</a></li>
<li><a href="#org8565377">运维多个数据中心</a></li>
<li><a href="#org7c6d1b9">收敛至一致的状态</a></li>
<li><a href="#orgf533da3">多主复制拓扑</a></li>
<li><a href="#org4b606bc">无主复制</a></li>
<li><a href="#org61c9f3c">当节点故障时写入数据库</a></li>
<li><a href="#orga6879de">读修复和反熵</a></li>
<li><a href="#orgb318f9b">读写的法定人数</a></li>
<li><a href="#org6beb9c0">法定人数一致性的局限性</a></li>
<li><a href="#org5e75701">监控陈旧度</a></li>
<li><a href="#org745c376">宽松的法定人数与提示移交</a></li>
<li><a href="#org4ebdae5">最后写入胜利（丢弃并发写入）</a></li>
<li><a href="#org0fa883b">“此前发生”的关系和并发</a></li>
<li><a href="#orgdb7f61f">并发性，时间和相对性</a></li>
</ol>
</li>
<li><a href="#orgbd78f04">分区</a><ol>
<li><a href="#org83101dd">键值数据的分区</a></li>
<li><a href="#org3367e3b">根据键的散列分区</a></li>
<li><a href="#org0319634">负载偏斜与热点消除</a></li>
<li><a href="#org105a9ea">分区与次级索引</a></li>
<li><a href="#orgb387133">基于文档的二级索引进行分区</a></li>
<li><a href="#orgfcc0d03">分区再平衡</a></li>
<li><a href="#org881d47d">再平衡策略</a></li>
<li><a href="#org2c626ab">请求路由</a></li>
<li><a href="#org518af59">本章小结</a></li>
</ol>
</li>
<li><a href="#orge83d8f0">事务</a><ol>
<li><a href="#orgfceddb9">ACID的含义</a></li>
<li><a href="#org9da65d1">多对象事务的需求</a></li>
<li><a href="#org22e0d8d">处理错误和终止</a></li>
<li><a href="#org0870c80">弱隔离级别</a></li>
<li><a href="#orgef84d76">读已提交</a></li>
<li><a href="#orge9f1034">实现读已提交</a></li>
<li><a href="#org7d3f167">快照隔离和可重复读</a></li>
<li><a href="#orgdff5241">实现快照隔离</a></li>
<li><a href="#org2fd44f6">冲突解决和复制</a></li>
<li><a href="#orgcea9c0a">写偏差的特征</a></li>
<li><a href="#org9ed5ed0">可串行化</a></li>
<li><a href="#orgaf4ee23">两阶段锁定</a></li>
<li><a href="#org7638aaa">实现两阶段锁</a></li>
<li><a href="#orgf43d8e7">索引范围锁</a></li>
<li><a href="#org8e8bcd7">悲观与乐观的并发控制</a></li>
<li><a href="#org8090f54">本章小结</a></li>
</ol>
</li>
<li><a href="#orgdaf2622">分布式系统的麻烦</a></li>
<li><a href="#orgc17a52f">一致性与共识</a><ol>
<li><a href="#org2eca161">共识的不可能性</a></li>
<li><a href="#orgb2c36d0">两阶段提交简介</a></li>
<li><a href="#orgb8033c6">三阶段提交</a></li>
<li><a href="#org1f27f30">XA事务</a></li>
<li><a href="#orgc8411ab">怀疑时持有锁</a></li>
<li><a href="#orgf039445">从协调者故障中恢复</a></li>
<li><a href="#orgbd8adbd">容错共识</a></li>
<li><a href="#org962ee39">共识算法和全序广播</a></li>
<li><a href="#orgf3a765f">单领导者复制与共识</a></li>
<li><a href="#org0931b1d">本章小结</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#org934c8d3">衍生数据</a><ol>
<li><a href="#org8e6f5da">流处理</a></li>
<li><a href="#org43fc32d">数据系统的未来</a><ol>
<li><a href="#org9fb0824">Lambda架构</a></li>
<li><a href="#org5c52457">分拆系统vs集成系统</a></li>
<li><a href="#org0929748">在数据系统中应用端到端思考</a></li>
<li><a href="#orgba709fb">强制约束</a></li>
<li><a href="#org5e50a64">唯一性约束需要达成共识</a></li>
<li><a href="#orge2f5be9">及时性与完整性</a></li>
<li><a href="#org17ed944">宽松地解释约束</a></li>
<li><a href="#orgea0a7b5">做正确的事情</a></li>
</ol>
</li>
</ol>
</li>
</ol>
<p><a id="org5114818"></a></p>
<h1 id="数据系统的基石"><a href="#数据系统的基石" class="headerlink" title="数据系统的基石"></a>数据系统的基石</h1><p><a id="org6dee7c9"></a></p>
<h2 id="可靠性、可伸缩性、可维护性"><a href="#可靠性、可伸缩性、可维护性" class="headerlink" title="可靠性、可伸缩性、可维护性"></a>可靠性、可伸缩性、可维护性</h2><ul>
<li><p>Netflix公司的Chaos Monkey【4】就是这种方法的一个例子。</p>
<ul>
<li>评论：好几本书都提到了网飞的混乱猴</li>
</ul>
</li>
<li><p>发布推文时，只需将新推文插入全局推文集合即可。当一个用户请求自己的主页时间线时，首先查找他关注的所有人，查询这些被关注用户发布的推文并按时间顺序合并。</p>
</li>
<li><p>为每个用户的主页时间线维护一个缓存，就像每个用户的推文收件箱（图1-3）。当一个用户发布推文时，查找所有关注该用户的人，并将新的推文插入到每个主页时间线缓存中。 因此读取主页时间线的请求开销很小，因为结果已经提前计算好了。</p>
</li>
<li><p>推特轶事的最终转折：现在已经稳健地实现了方法2，推特逐步转向了两种方法的混合。</p>
</li>
<li><p>一旦系统的负载被描述好，就可以研究当负载增加会发生什么。我们可以从两种角度来看：增加负载参数并保持系统资源（CPU、内存、网络带宽等）不变时，系统性能将受到什么影响？增加负载参数并希望保持性能不变时，需要增加多少系统资源？</p>
</li>
<li><p>对于Hadoop这样的批处理系统，通常关心的是吞吐量（throughput），即每秒可以处理的记录数量，或者在特定规模数据集上运行作业的总时间iii。对于在线系统，通常更重要的是服务的响应时间（response time），即客户端发送请求到接收响应之间的时间。</p>
</li>
<li><p>如果想知道典型场景下用户需要等待多长时间，那么中位数是一个好的度量标准：一半用户请求的响应时间少于响应时间的中位数，另一半服务时间比中位数长。</p>
</li>
<li><p>为了弄清异常值有多糟糕，可以看看更高的百分位点，例如第95、99和99.9百分位点（缩写为p95，p99和p999）。</p>
</li>
<li><p>提供良好的默认行为，但需要时也允许管理员自由覆盖默认值。</p>
<ul>
<li>评论：参数可配置，可以少很多代码改动</li>
</ul>
</li>
<li><p>系统的需求永远不变，基本是不可能的。</p>
<ul>
<li>评论：需求的本质就是不停地在变</li>
</ul>
</li>
</ul>
<p><a id="orgf3822ce"></a></p>
<h2 id="数据模型与查询语言"><a href="#数据模型与查询语言" class="headerlink" title="数据模型与查询语言"></a>数据模型与查询语言</h2><ul>
<li><p>一个经验法则是，如果重复存储了可以存储在一个地方的值，则模式就不是规范化（normalized） 的。</p>
<ul>
<li>评论：数据冗余，浪费存储空间且加大开发修改的难度</li>
</ul>
</li>
<li><p>对高度关联的数据而言，文档模型是极其糟糕的，关系模型是可以接受的，而选用图形模型（请参阅“图数据模型”）是最自然的。</p>
</li>
<li><p>如我们之前所见，多对多关系是不同数据模型之间具有区别性的重要特征。如果你的应用程序大多数的关系是一对多关系（树状结构化数据），或者大多数记录之间不存在关系，那么使用文档模型是合适的。</p>
</li>
</ul>
<p><a id="orgc307b6e"></a></p>
<h2 id="存储与检索"><a href="#存储与检索" class="headerlink" title="存储与检索"></a>存储与检索</h2><ul>
<li><p>例如，每个叶子页面可以在左边和右边具有对其兄弟页面的引用，这允许不跳回父页面就能顺序扫描。</p>
<ul>
<li>评论：mysql的innodb数据结构B+树</li>
</ul>
</li>
<li><p>这些OLTP系统往往对业务运作至关重要，因而通常会要求 高可用 与 低延迟。所以DBA会密切关注他们的OLTP数据库，他们通常不愿意让业务分析人员在OLTP数据库上运行临时分析查询，因为这些查询通常开销巨大，会扫描大部分数据集，这会损害同时执行的事务的性能。</p>
</li>
<li><p>几乎所有的大型企业都有数据仓库，但在小型企业中几乎闻所未闻</p>
<ul>
<li>评论：小型企业用不上</li>
</ul>
</li>
<li><p>我们看到存储引擎分为两大类：优化 事务处理（OLTP） 或 在线分析（OLAP） 。</p>
</li>
</ul>
<p><a id="org06331d9"></a></p>
<h2 id="编码与演化"><a href="#编码与演化" class="headerlink" title="编码与演化"></a>编码与演化</h2><ul>
<li><p>有两种流行的Web服务方法：REST和SOAP。他们在哲学方面几乎是截然相反的，往往也是各自支持者之间的激烈辩论的主题vi。</p>
<ul>
<li>SOAP Web服务的API使用称为Web服务描述语言（WSDL）的基于XML的语言来描述。</li>
<li>RESTful API还有其他一些显著的优点：方便实验和调试（只需使用Web浏览器或命令行工具curl，无需任何代码生成或软件安装即可向其请求），能被所有主流的编程语言和平台所支持，还有大量可用的工具（服务器，缓存，负载平衡器，代理，防火墙，监控，调试工具，测试工具等）的生态系统。</li>
</ul>
</li>
<li><p>REST似乎是公共API的主要风格。 RPC框架的主要重点在于同一组织拥有的服务之间的请求，通常在同一数据中心内。</p>
</li>
<li><p>对于RESTful API，常用的方法是在URL或HTTP Accept头中使用版本号。对于使用API密钥来标识特定客户端的服务，另一种选择是将客户端请求的API版本存储在服务器上，并允许通过单独的管理界面更新该版本选项【49】。</p>
</li>
</ul>
<p><a id="org54fbf05"></a></p>
<h1 id="分布式数据"><a href="#分布式数据" class="headerlink" title="分布式数据"></a>分布式数据</h1><ul>
<li>如果你需要的只是伸缩至更高的载荷（load），最简单的方法就是购买更强大的机器（有时称为垂直伸缩（vertical scaling） 或向上伸缩（scale up））。</li>
</ul>
<p><a id="orgf82f0d5"></a></p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><ul>
<li>我们希望能复制数据，可能出于各种各样的原因：使得数据与用户在地理上接近（从而减少延迟）即使系统的一部分出现故障，系统也能继续工作（从而提高可用性）伸缩可以接受读请求的机器数量（从而提高读取吞吐量）。</li>
</ul>
<p><a id="org7c5e7b9"></a></p>
<h3 id="同步复制与异步复制"><a href="#同步复制与异步复制" class="headerlink" title="同步复制与异步复制"></a>同步复制与异步复制</h3><ul>
<li><p>因此，将所有从库都设置为同步的是不切实际的：任何一个节点的中断都会导致整个系统停滞不前。实际上，如果在数据库上启用同步复制，通常意味着其中一个跟随者是同步的，而其他的则是异步的。</p>
</li>
<li><p>然而，一个完全异步的配置也有优点：即使所有的从库都落后了，主库也可以继续处理写入。</p>
</li>
</ul>
<p><a id="orgcfe55f0"></a></p>
<h3 id="设置新从库"><a href="#设置新从库" class="headerlink" title="设置新从库"></a>设置新从库</h3><ul>
<li><p>在某个时刻获取主库的一致性快照（如果可能），而不必锁定整个数据库。</p>
</li>
<li><p>从库连接到主库，并拉取快照之后发生的所有数据变更。</p>
</li>
</ul>
<p><a id="org4a94680"></a></p>
<h3 id="主库失效：故障切换"><a href="#主库失效：故障切换" class="headerlink" title="主库失效：故障切换"></a>主库失效：故障切换</h3><ul>
<li><p>自动故障切换过程通常由以下步骤组成：</p>
<ul>
<li>确认主库失效。</li>
<li>选择一个新的主库。这可以通过选举过程（主库由剩余副本以多数选举产生）来完成，或者可以由之前选定的控制器节点（controller node） 来指定新的主库。</li>
<li>重新配置系统以启用新的主库。客户端现在需要将它们的写请求发送给新主库（将在“请求路由”中讨论这个问题）。如果老领导回来，可能仍然认为自己是主库，没有意识到其他副本已经让它下台了。系统需要确保老领导认可新领导，成为一个从库。<ul>
<li>评论：脑裂，一般用版本来区分新旧主库</li>
</ul>
</li>
</ul>
</li>
<li><p>如果数据库需要和其他外部存储相协调，那么丢弃写入内容是极其危险的操作。</p>
</li>
</ul>
<p><a id="org5929a85"></a></p>
<h3 id="复制日志的实现"><a href="#复制日志的实现" class="headerlink" title="复制日志的实现"></a>复制日志的实现</h3><p>基于主库的复制底层是如何工作的？实践中有好几种不同的复制方式，所以先简要地看一下。</p>
<ol>
<li><p>基于语句的复制</p>
<ul>
<li><p>在最简单的情况下，主库记录下它执行的每个写入请求（语句（statement））并将该语句日志发送给其从库。</p>
</li>
<li><p>虽然听上去很合理，但有很多问题会搞砸这种复制方式：</p>
<ul>
<li>任何调用 非确定性函数（nondeterministic） 的语句，可能会在每个副本上生成不同的值。例如，使用NOW()获取当前日期时间，或使用RAND()获取一个随机数。</li>
<li>有副作用的语句（例如，触发器，存储过程，用户定义的函数）可能会在每个副本上产生不同的副作用，除非副作用是绝对确定的。</li>
<li>基于语句的复制在5.1版本前的MySQL中使用。因为它相当紧凑，现在有时候也还在用。但现在在默认情况下，如果语句中存在任何不确定性，MySQL会切换到基于行的复制（稍后讨论）。</li>
</ul>
</li>
</ul>
</li>
<li><p>传输预写式日志（WAL）</p>
<ul>
<li>PostgreSQL和Oracle等使用这种复制方法【16】。主要缺点是日志记录的数据非常底层：WAL包含哪些磁盘块中的哪些字节发生了更改。这使复制与存储引擎紧密耦合。如果数据库将其存储格式从一个版本更改为另一个版本，通常不可能在主库和从库上运行不同版本的数据库软件。</li>
</ul>
</li>
<li><p>逻辑日志复制（基于行）</p>
<ul>
<li>关系数据库的逻辑日志通常是以行的粒度描述对数据库表的写入的记录序列：</li>
</ul>
</li>
<li><p>基于触发器的复制</p>
<ul>
<li>基于触发器的复制通常比其他复制方法具有更高的开销，并且比数据库的内置复制更容易出错，也有很多限制。然而由于其灵活性，仍然是很有用的。</li>
</ul>
</li>
<li><p>复制延迟问题</p>
<ul>
<li>这种不一致只是一个暂时的状态——如果停止写入数据库并等待一段时间，从库最终会赶上并与主库保持一致。出于这个原因，这种效应被称为 最终一致性（eventual consistency)。</li>
</ul>
</li>
</ol>
<p><a id="org68cb07c"></a></p>
<h3 id="读己之写"><a href="#读己之写" class="headerlink" title="读己之写"></a>读己之写</h3><ul>
<li><p>如果用户在写入后马上就查看数据，则新数据可能尚未到达副本。对用户而言，看起来好像是刚提交的数据丢失了，用户会不高兴，可以理解。</p>
</li>
<li><p>在这种情况下，我们需要 读写一致性（read-after-write consistency），也称为 读己之写一致性（read-your-writes consistency）【24】。</p>
</li>
<li><p>读用户可能已经修改过的内容时，都从主库读。</p>
</li>
<li><p>例如可以跟踪上次更新的时间，在上次更新后的一分钟内，从主库读。还可以监控从库的复制延迟，防止对任意比主库滞后超过一分钟的从库发出查询。</p>
</li>
<li><p>另一种复杂的情况是：如果同一个用户从多个设备请求服务，例如桌面浏览器和移动APP。这种情况下可能就需要提供跨设备的写后读一致性：如果用户在某个设备上输入了一些信息，然后在另一个设备上查看，则应该看到他们刚输入的信息。</p>
</li>
<li><p>记住用户上次更新时间戳的方法变得更加困难，因为一台设备上运行的程序不知道另一台设备上发生了什么。元数据需要一个中心存储。</p>
</li>
</ul>
<p><a id="orga49fd85"></a></p>
<h3 id="单调读"><a href="#单调读" class="headerlink" title="单调读"></a>单调读</h3><ul>
<li><p>从异步从库读取第二个异常例子是，用户可能会遇到 时光倒流（moving backward in time）。</p>
</li>
<li><p>实现单调读取的一种方式是确保每个用户总是从同一个副本进行读取（不同的用户可以从不同的副本读取）。例如，可以基于用户ID的散列来选择副本，而不是随机选择副本。但是，如果该副本失败，用户的查询将需要重新路由到另一个副本。</p>
</li>
</ul>
<p><a id="orgd9579ac"></a></p>
<h3 id="一致前缀读"><a href="#一致前缀读" class="headerlink" title="一致前缀读"></a>一致前缀读</h3><ul>
<li><p>第三个复制延迟例子违反了因果律。</p>
</li>
<li><p>防止这种异常，需要另一种类型的保证：一致前缀读（consistent prefix reads）【23】。 这个保证说：如果一系列写入按某个顺序发生，那么任何人读取这些写入时，也会看见它们以同样的顺序出现。</p>
</li>
<li><p>这是分区（partitioned）（分片（sharded））数据库中的一个特殊问题</p>
</li>
</ul>
<p><a id="org89f52a8"></a></p>
<h3 id="复制延迟的解决方案"><a href="#复制延迟的解决方案" class="headerlink" title="复制延迟的解决方案"></a>复制延迟的解决方案</h3><ul>
<li><p>在使用最终一致的系统时，如果复制延迟增加到几分钟甚至几小时，则应该考虑应用程序的行为。</p>
</li>
<li><p>如果应用程序开发人员不必担心微妙的复制问题，并可以信赖他们的数据库“做了正确的事情”，那该多好呀。这就是 事务（transaction） 存在的原因：数据库通过事务提供强大的保证，所以应用程序可以更加简单。</p>
</li>
</ul>
<p><a id="orgc63650e"></a></p>
<h3 id="多主复制"><a href="#多主复制" class="headerlink" title="多主复制"></a>多主复制</h3><ul>
<li><p>基于领导者的复制有一个主要的缺点：只有一个主库，而所有的写入都必须通过它iv。如果出于任何原因（例如和主库之间的网络连接中断）无法连接到主库，就无法向数据库写入。</p>
</li>
<li><p>基于领导者的复制模型的自然延伸是允许多个节点接受写入。 复制仍然以同样的方式发生：处理写入的每个节点都必须将该数据更改转发给所有其他节点。称之为多领导者配置（也称多主、多活复制）。 在这种情况下，每个领导者同时扮演其他领导者的追随者。</p>
</li>
</ul>
<p><a id="org4eb85fb"></a></p>
<h3 id="多主复制的应用场景"><a href="#多主复制的应用场景" class="headerlink" title="多主复制的应用场景"></a>多主复制的应用场景</h3><p><a id="org8565377"></a></p>
<h3 id="运维多个数据中心"><a href="#运维多个数据中心" class="headerlink" title="运维多个数据中心"></a>运维多个数据中心</h3><ol>
<li><p>容忍数据中心停机</p>
<ul>
<li>在单主配置中，如果主库所在的数据中心发生故障，故障切换可以使另一个数据中心里的追随者成为领导者。在多活配置中，每个数据中心可以独立于其他数据中心继续运行，并且当发生故障的数据中心归队时，复制会自动赶上。</li>
</ul>
</li>
</ol>
<p><a id="org7c6d1b9"></a></p>
<h3 id="收敛至一致的状态"><a href="#收敛至一致的状态" class="headerlink" title="收敛至一致的状态"></a>收敛至一致的状态</h3><ul>
<li><p>因此，数据库必须以一种 收敛（convergent） 的方式解决冲突，这意味着所有副本必须在所有变更复制完成时收敛至一个相同的最终值。</p>
</li>
<li><p>给每个写入一个唯一的ID（例如，一个时间戳，一个长的随机数，一个UUID或者一个键和值的哈希），挑选最高ID的写入作为胜利者，并丢弃其他写入。如果使用时间戳，这种技术被称为最后写入胜利（LWW, last write wins）</p>
</li>
</ul>
<p><a id="orgf533da3"></a></p>
<h3 id="多主复制拓扑"><a href="#多主复制拓扑" class="headerlink" title="多主复制拓扑"></a>多主复制拓扑</h3><ul>
<li><p>复制拓扑（replication topology）描述写入从一个节点传播到另一个节点的通信路径。</p>
</li>
<li><p>要正确排序这些事件，可以使用一种称为 版本向量（version vectors） 的技术，本章稍后将讨论这种技术（请参阅“检测并发写入”）。然而，冲突检测技术在许多多领导者复制系统中执行得不好。例如，在撰写本文时，PostgreSQL BDR不提供写入的因果排序【27】，而Tungsten Replicator for MySQL甚至不尝试检测冲突【34】。</p>
</li>
<li><p>如果您正在使用具有多领导者复制功能的系统，那么应该了解这些问题，仔细阅读文档，并彻底测试您的数据库，以确保它确实提供了您认为具有的保证。</p>
</li>
</ul>
<p><a id="org4b606bc"></a></p>
<h3 id="无主复制"><a href="#无主复制" class="headerlink" title="无主复制"></a>无主复制</h3><ul>
<li>一些数据存储系统采用不同的方法，放弃主库的概念，并允许任何副本直接接受来自客户端的写入。</li>
</ul>
<p><a id="org61c9f3c"></a></p>
<h3 id="当节点故障时写入数据库"><a href="#当节点故障时写入数据库" class="headerlink" title="当节点故障时写入数据库"></a>当节点故障时写入数据库</h3><ul>
<li><p>不可用的节点重新联机，客户端开始读取它。节点关闭时发生的任何写入都从该节点丢失。因此，如果您从该节点读取数据，则可能会将陈旧（过时）值视为响应。</p>
</li>
<li><p>为了解决这个问题，当一个客户端从数据库中读取数据时，它不仅仅发送它的请求到一个副本：读请求也被并行地发送到多个节点。</p>
</li>
<li><p>客户可能会从不同的节点获得不同的响应。即来自一个节点的最新值和来自另一个节点的陈旧值。版本号用于确定哪个值更新（请参阅“检测并发写入”）。</p>
</li>
</ul>
<p><a id="orga6879de"></a></p>
<h3 id="读修复和反熵"><a href="#读修复和反熵" class="headerlink" title="读修复和反熵"></a>读修复和反熵</h3><ul>
<li>复制方案应确保最终将所有数据复制到每个副本。在一个不可用的节点重新联机之后，它如何赶上它错过的写入？</li>
</ul>
<ol>
<li><p>读修复（Read repair）</p>
<ul>
<li>当客户端并行读取多个节点时，它可以检测到任何陈旧的响应。例如，在图5-10中，用户2345获得了来自副本3的版本6值和来自副本1和2的版本7值。客户端发现副本3具有陈旧值，并将新值写回到该副本。这种方法适用于读频繁的值。</li>
</ul>
</li>
<li><p>反熵过程（Anti-entropy process）</p>
<ul>
<li><p>此外，一些数据存储具有后台进程，该进程不断查找副本之间的数据差异，并将任何缺少的数据从一个副本复制到另一个副本。与基于领导者的复制中的复制日志不同，此反熵过程不会以任何特定的顺序复制写入，并且在复制数据之前可能会有显著的延迟。</p>
</li>
<li><p>请注意，如果没有反熵过程，某些副本中很少读取的值可能会丢失，从而降低了持久性，因为只有在应用程序读取值时才执行读修复。</p>
<ul>
<li>评论：当副本数较少的时候，并且一个数值的读频率比较低，这个时候其他版本比较新的副本下线，程序此时读取到的数据就会是比较旧的值，出现不一致。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><a id="orgb318f9b"></a></p>
<h3 id="读写的法定人数"><a href="#读写的法定人数" class="headerlink" title="读写的法定人数"></a>读写的法定人数</h3><ul>
<li>通常，读取和写入操作始终并行发送到所有n个副本<ul>
<li>评论：所以一般副本数设奇数位</li>
</ul>
</li>
</ul>
<p><a id="org6beb9c0"></a></p>
<h3 id="法定人数一致性的局限性"><a href="#法定人数一致性的局限性" class="headerlink" title="法定人数一致性的局限性"></a>法定人数一致性的局限性</h3><ul>
<li><p>如果两个写入同时发生，不清楚哪一个先发生。在这种情况下，唯一安全的解决方案是合并并发写入（请参阅“处理写入冲突”）。</p>
</li>
<li><p>Dynamo风格的数据库通常针对可以忍受最终一致性的用例进行优化。允许通过参数w和r来调整读取陈旧值的概率，但把它们当成绝对的保证是不明智的。</p>
</li>
</ul>
<p><a id="org5e75701"></a></p>
<h3 id="监控陈旧度"><a href="#监控陈旧度" class="headerlink" title="监控陈旧度"></a>监控陈旧度</h3><ul>
<li>然而，在无领导者复制的系统中，没有固定的写入顺序，这使得监控变得更加困难。而且，如果数据库只使用读修复（没有反熵过程）​，那么对于一个值可能会有多大的限制是没有限制的 - 如果一个值很少被读取，那么由一个陈旧副本返回的值可能是古老的。</li>
</ul>
<p><a id="org745c376"></a></p>
<h3 id="宽松的法定人数与提示移交"><a href="#宽松的法定人数与提示移交" class="headerlink" title="宽松的法定人数与提示移交"></a>宽松的法定人数与提示移交</h3><ul>
<li>对于需要高可用、低延时、且能够容忍偶尔读到陈旧值的应用场景来说，这些特性使无主复制的数据库很有吸引力。</li>
</ul>
<p><a id="org4ebdae5"></a></p>
<h3 id="最后写入胜利（丢弃并发写入）"><a href="#最后写入胜利（丢弃并发写入）" class="headerlink" title="最后写入胜利（丢弃并发写入）"></a>最后写入胜利（丢弃并发写入）</h3><ul>
<li>有一些情况，如缓存，其中丢失的写入可能是可以接受的。如果丢失数据不可接受，LWW是解决冲突的一个很烂的选择。</li>
</ul>
<p><a id="org0fa883b"></a></p>
<h3 id="“此前发生”的关系和并发"><a href="#“此前发生”的关系和并发" class="headerlink" title="“此前发生”的关系和并发"></a>“此前发生”的关系和并发</h3><ul>
<li>事实上，我们可以简单地说，如果两个操作都不在另一个之前发生，那么两个操作是并发的（即，两个操作都不知道另一个）【54】。</li>
</ul>
<p><a id="orgdb7f61f"></a></p>
<h3 id="并发性，时间和相对性"><a href="#并发性，时间和相对性" class="headerlink" title="并发性，时间和相对性"></a>并发性，时间和相对性</h3><ul>
<li><p>为了定义并发性，确切的时间并不重要：如果两个操作都意识不到对方的存在，就称这两个操作并发，而不管它们发生的物理时间。</p>
</li>
<li><p>我们考察了复制的问题。复制可以用于几个目的：</p>
<ul>
<li>高可用性</li>
<li>断开连接的操作</li>
<li>延迟</li>
<li>可伸缩性</li>
</ul>
</li>
<li><p>我们讨论了复制的三种主要方法：</p>
<ul>
<li>单主复制</li>
<li>多主复制</li>
<li>无主复制</li>
</ul>
</li>
<li><p>每种方法都有优点和缺点。单主复制是非常流行的，因为它很容易理解，不需要担心冲突解决。在出现故障节点，网络中断和延迟峰值的情况下，多领导者和无领导者复制可以更加稳健，但以更难以推理并仅提供非常弱的一致性保证为代价。</p>
</li>
<li><p>我们也讨论了一些有助于决定应用程序在复制滞后时的行为的一致性模型：</p>
<ul>
<li>写后读：用户应该总是看到自己提交的数据。</li>
<li>单调读：用户在一个时间点看到数据后，他们不应该在某个更早的时间点看到数据</li>
<li>一致前缀读：用户应该将数据视为具有因果意义的状态：例如，按照正确的顺序查看问题及其答复。</li>
</ul>
</li>
</ul>
<p><a id="orgbd78f04"></a></p>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p><a id="org83101dd"></a></p>
<h3 id="键值数据的分区"><a href="#键值数据的分区" class="headerlink" title="键值数据的分区"></a>键值数据的分区</h3><ul>
<li><p>避免热点最简单的方法是将记录随机分配给节点。这将在所有节点上平均分配数据，但是它有一个很大的缺点：当你试图读取一个特定的值时，你无法知道它在哪个节点上，所以你必须并行地查询所有的节点。</p>
</li>
<li><p>我们可以做得更好。现在假设您有一个简单的键值数据模型，其中您总是通过其主键访问记录。例如，在一本老式的纸质百科全书中，你可以通过标题来查找一个条目；由于所有条目按字母顺序排序，因此您可以快速找到您要查找的条目。</p>
<ul>
<li>评论：这个就需要注意一下重平衡之后，数据存储的位置也要进行相应的调整才能正确查询到。</li>
</ul>
</li>
</ul>
<p><a id="org3367e3b"></a></p>
<h3 id="根据键的散列分区"><a href="#根据键的散列分区" class="headerlink" title="根据键的散列分区"></a>根据键的散列分区</h3><ul>
<li>这种技术擅长在分区之间公平地分配键。分区边界可以是均匀间隔的，也可以是伪随机选择的（在这种情况下，该技术有时也被称为一致性哈希（consistent hashing））。</li>
</ul>
<p><a id="org0319634"></a></p>
<h3 id="负载偏斜与热点消除"><a href="#负载偏斜与热点消除" class="headerlink" title="负载偏斜与热点消除"></a>负载偏斜与热点消除</h3><ul>
<li>如今，大多数数据系统无法自动补偿这种高度偏斜的负载，因此应用程序有责任减少偏斜。例如，如果一个主键被认为是非常火爆的，一个简单的方法是在主键的开始或结尾添加一个随机数。只要一个两位数的十进制随机数就可以将主键分散为100种不同的主键,从而存储在不同的分区中。</li>
</ul>
<p><a id="org105a9ea"></a></p>
<h3 id="分区与次级索引"><a href="#分区与次级索引" class="headerlink" title="分区与次级索引"></a>分区与次级索引</h3><ul>
<li>如果涉及次级索引，情况会变得更加复杂（参考“其他索引结构”）。辅助索引通常并不能唯一地标识记录，而是一种搜索记录中出现特定值的方式：查找用户123的所有操作，查找包含词语hogwash的所有文章，查找所有颜色为红色的车辆等等。</li>
</ul>
<p><a id="orgb387133"></a></p>
<h3 id="基于文档的二级索引进行分区"><a href="#基于文档的二级索引进行分区" class="headerlink" title="基于文档的二级索引进行分区"></a>基于文档的二级索引进行分区</h3><ul>
<li><p>但是，从文档分区索引中读取需要注意：除非您对文档ID做了特别的处理，否则没有理由将所有具有特定颜色或特定品牌的汽车放在同一个分区中。在图6-4中，红色汽车出现在分区0和分区1中。因此，如果要搜索红色汽车，则需要将</p>
</li>
<li><p>这种查询分区数据库的方法有时被称为分散&#x2F;聚集（scatter&#x2F;gather），并且可能会使二级索引上的读取查询相当昂贵。即使并行查询分区，分散&#x2F;聚集也容易导致尾部延迟放大（请参阅“实践中的百分位点”</p>
</li>
</ul>
<p><a id="orgfcc0d03"></a></p>
<h3 id="分区再平衡"><a href="#分区再平衡" class="headerlink" title="分区再平衡"></a>分区再平衡</h3><p><a id="org881d47d"></a></p>
<h3 id="再平衡策略"><a href="#再平衡策略" class="headerlink" title="再平衡策略"></a>再平衡策略</h3><ol>
<li><p>反面教材：hash mod N</p>
<ul>
<li><p>模N（$mod N$）方法的问题是，如果节点数量N发生变化，大多数键将需要从一个节点移动到另一个节点。例如，假设$hash(key)&#x3D;123456$。如果最初有10个节点，那么这个键一开始放在节点6上（因为$123456\ mod\ 10 &#x3D; 6$）。当您增长到11个节点时，键需要移动到节点3（$123456\ mod\ 11 &#x3D; 3$），当您增长到12个节点时，需要移动到节点0（$123456\ mod\ 12 &#x3D; 0$）。这种频繁的举动使得重新平衡过于昂贵。</p>
</li>
<li><p>我们需要一种只移动必需数据的方法。</p>
</li>
</ul>
</li>
<li><p>固定数量的分区</p>
<ul>
<li>幸运的是，有一个相当简单的解决方案：创建比节点更多的分区，并为每个节点分配多个分区。</li>
</ul>
</li>
</ol>
<p><a id="org2c626ab"></a></p>
<h3 id="请求路由"><a href="#请求路由" class="headerlink" title="请求路由"></a>请求路由</h3><ul>
<li><p>这个问题可以概括为 服务发现(service discovery) ，它不仅限于数据库。</p>
</li>
<li><p>概括来说，这个问题有几种不同的方案（如图6-7所示）:</p>
</li>
<li><p>允许客户联系任何节点（例如，通过循环策略的负载均衡（Round-Robin Load Balancer））。如果该节点恰巧拥有请求的分区，则它可以直接处理该请求；否则，它将请求转发到适当的节点，接收回复并传递给客户端。</p>
</li>
<li><p>首先将所有来自客户端的请求发送到路由层，它决定了应该处理请求的节点，并相应地转发。此路由层本身不处理任何请求；它仅负责分区的负载均衡。</p>
</li>
<li><p>要求客户端知道分区和节点的分配。在这种情况下，客户端可以直接连接到适当的节点，而不需要任何中介。</p>
</li>
<li><p>许多分布式数据系统都依赖于一个独立的协调服务，比如ZooKeeper来跟踪集群元数据，如图6-8所示。 每个节点在ZooKeeper中注册自己，ZooKeeper维护分区到节点的可靠映射。 其他参与者（如路由层或分区感知客户端）可以在ZooKeeper中订阅此信息。 只要分区分配发生了改变，或者集群中添加或删除了一个节点，ZooKeeper就会通知路由层使路由信息保持最新状态。</p>
</li>
</ul>
<p><a id="org518af59"></a></p>
<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><ul>
<li>分区的目标是在多台机器上均匀分布数据和查询负载，避免出现热点（负载不成比例的节点）。这需要选择适合于您的数据的分区方案，并在将节点添加到集群或从集群删除时进行分区再平衡。</li>
</ul>
<ol>
<li><p>键范围分区</p>
</li>
<li><p>散列分区</p>
</li>
</ol>
<p><a id="orge83d8f0"></a></p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p><a id="orgfceddb9"></a></p>
<h3 id="ACID的含义"><a href="#ACID的含义" class="headerlink" title="ACID的含义"></a>ACID的含义</h3><ul>
<li>事务所提供的安全保证，通常由众所周知的首字母缩略词ACID来描述，ACID代表原子性（Atomicity），一致性（Consistency），隔离性（Isolation） 和持久性（Durability）。</li>
</ul>
<ol>
<li><p>原子性</p>
<ul>
<li><p>原子性简化了这个问题：如果事务被中止（abort），应用程序可以确定它没有改变任何东西，所以可以安全地重试。</p>
</li>
<li><p>ACID原子性的定义特征是：能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力。 或许 可中止性（abortability） 是更好的术语，但本书将继续使用原子性，因为这是惯用词。</p>
</li>
</ul>
</li>
<li><p>一致性</p>
<ul>
<li><p>ACID一致性的概念是，对数据的一组特定约束必须始终成立。即不变量（invariants）。</p>
</li>
<li><p>原子性，隔离性和持久性是数据库的属性，而一致性（在ACID意义上）是应用程序的属性。</p>
</li>
</ul>
</li>
</ol>
<p><a id="org9da65d1"></a></p>
<h3 id="多对象事务的需求"><a href="#多对象事务的需求" class="headerlink" title="多对象事务的需求"></a>多对象事务的需求</h3><ul>
<li>许多分布式数据存储已经放弃了多对象事务，因为多对象事务很难跨分区实现，而且在需要高可用性或高性能的情况下，它们可能会碍事。但说到底，在分布式数据库中实现事务，并没有什么根本性的障碍。第九章 将讨论分布式事务的实现。</li>
</ul>
<p><a id="org22e0d8d"></a></p>
<h3 id="处理错误和终止"><a href="#处理错误和终止" class="headerlink" title="处理错误和终止"></a>处理错误和终止</h3><ul>
<li><p>事务的一个关键特性是，如果发生错误，它可以中止并安全地重试。 ACID数据库基于这样的哲学：如果数据库有违反其原子性，隔离性或持久性的危险，则宁愿完全放弃事务，而不是留下半成品。</p>
</li>
<li><p>如果你想确保几个不同的系统一起提交或放弃，两阶段提交（2PC, two-phase commit） 可以提供帮助（“原子提交与两阶段提交”中将讨论这个问题）。</p>
</li>
</ul>
<p><a id="org0870c80"></a></p>
<h3 id="弱隔离级别"><a href="#弱隔离级别" class="headerlink" title="弱隔离级别"></a>弱隔离级别</h3><ul>
<li>可串行的隔离会有性能损失，许多数据库不愿意支付这个代价【8】。</li>
</ul>
<p><a id="orgef84d76"></a></p>
<h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><ul>
<li>最基本的事务隔离级别是读已提交（Read Committed）v，它提供了两个保证：从数据库读时，只能看到已提交的数据（没有脏读（dirty reads））。写入数据库时，只会覆盖已经写入的数据（没有脏写（dirty writes））。</li>
</ul>
<p><a id="orge9f1034"></a></p>
<h3 id="实现读已提交"><a href="#实现读已提交" class="headerlink" title="实现读已提交"></a>实现读已提交</h3><ul>
<li><p>读已提交是一个非常流行的隔离级别。这是Oracle 11g，PostgreSQL，SQL Server 2012，MemSQL和其他许多数据库的默认设置【8】。</p>
<ul>
<li>评论：mysql默认是RR，可重复读</li>
</ul>
</li>
<li><p>出于这个原因，大多数数据库vi使用图7-4的方式防止脏读：对于写入的每个对象，数据库都会记住旧的已提交值，和由当前持有写入锁的事务设置的新值。当事务正在进行时，任何其他读取对象的事务都会拿到旧值。 只有当新值提交后，事务才会切换到读取新值。</p>
</li>
</ul>
<p><a id="org7d3f167"></a></p>
<h3 id="快照隔离和可重复读"><a href="#快照隔离和可重复读" class="headerlink" title="快照隔离和可重复读"></a>快照隔离和可重复读</h3><ol>
<li><p>分析查询和完整性检查</p>
<ul>
<li><p>快照隔离（snapshot isolation）【28】是这个问题最常见的解决方案。想法是，每个事务都从数据库的一致快照（consistent snapshot） 中读取——也就是说，事务可以看到事务开始时在数据库中提交的所有数据。即使这些数据随后被另一个事务更改，每个事务也只能看到该特定时间点的旧数据。</p>
</li>
<li><p>快照隔离是一个流行的功能：PostgreSQL，使用InnoDB引擎的MySQL，Oracle，SQL Server等都支持【23,31,32】。</p>
</li>
</ul>
</li>
</ol>
<p><a id="orgdff5241"></a></p>
<h3 id="实现快照隔离"><a href="#实现快照隔离" class="headerlink" title="实现快照隔离"></a>实现快照隔离</h3><ul>
<li><p>快照隔离的一个关键原则是：读不阻塞写，写不阻塞读。</p>
</li>
<li><p>因为它同时维护着单个对象的多个版本，所以这种技术被称为多版本并发控制（MVCC, multi-version concurrency control）。</p>
</li>
</ul>
<p><a id="org2fd44f6"></a></p>
<h3 id="冲突解决和复制"><a href="#冲突解决和复制" class="headerlink" title="冲突解决和复制"></a>冲突解决和复制</h3><ul>
<li>另一方面，最后写入胜利（LWW）的冲突解决方法很容易丢失更新，如“最后写入胜利（丢弃并发写入）”中所述。不幸的是，LWW是许多复制数据库中的默认方案。</li>
</ul>
<p><a id="orgcea9c0a"></a></p>
<h3 id="写偏差的特征"><a href="#写偏差的特征" class="headerlink" title="写偏差的特征"></a>写偏差的特征</h3><ul>
<li>可以将写入偏差视为丢失更新问题的一般化。如果两个事务读取相同的对象，然后更新其中一些对象（不同的事务可能更新不同的对象），则可能发生写入偏差。在多个事务更新同一个对象的特殊情况下，就会发生脏写或丢失更新（取决于时序）。</li>
</ul>
<p><a id="org9ed5ed0"></a></p>
<h3 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h3><ul>
<li><p>目前大多数提供可串行化的数据库都使用了三种技术之一，本章的剩余部分将会介绍这些技术：</p>
</li>
<li><p>两阶段锁定（2PL, two-phase locking），几十年来唯一可行的选择（请参阅“两阶段锁定”）</p>
</li>
<li><p>乐观并发控制技术，例如可串行化快照隔离（serializable snapshot isolation）（请参阅“可串行化快照隔离”）</p>
</li>
</ul>
<p><a id="orgaf4ee23"></a></p>
<h3 id="两阶段锁定"><a href="#两阶段锁定" class="headerlink" title="两阶段锁定"></a>两阶段锁定</h3><ul>
<li><p>大约30年来，在数据库中只有一种广泛使用的串行化算法：两阶段锁定（2PL，two-phase locking）xi</p>
</li>
<li><p>在2PL中，写入不仅会阻塞其他写入，也会阻塞读，反之亦然。快照隔离使得读不阻塞写，写也不阻塞读（请参阅“实现快照隔离”​）​，这是2PL和快照隔离之间的关键区别。</p>
</li>
</ul>
<p><a id="org7638aaa"></a></p>
<h3 id="实现两阶段锁"><a href="#实现两阶段锁" class="headerlink" title="实现两阶段锁"></a>实现两阶段锁</h3><ul>
<li>2PL用于MySQL（InnoDB）和SQL Server中的可串行化隔离级别，以及DB2中的可重复读隔离级别【23,36】​。</li>
</ul>
<p><a id="orgf43d8e7"></a></p>
<h3 id="索引范围锁"><a href="#索引范围锁" class="headerlink" title="索引范围锁"></a>索引范围锁</h3><ul>
<li>不幸的是谓词锁性能不佳：如果活跃事务持有很多锁，检查匹配的锁会非常耗时。因此，大多数使用2PL的数据库实际上实现了索引范围锁（也称为间隙锁（next-key locking））​，这是一个简化的近似版谓词锁【41,50】​。</li>
</ul>
<p><a id="org8e8bcd7"></a></p>
<h3 id="悲观与乐观的并发控制"><a href="#悲观与乐观的并发控制" class="headerlink" title="悲观与乐观的并发控制"></a>悲观与乐观的并发控制</h3><ul>
<li><p>两阶段锁是一种所谓的悲观并发控制机制（pessimist​ic） ：它是基于这样的原则：如果有事情可能出错（如另一个事务所持有的锁所表示的）​，最好等到情况安全后再做任何事情。这就像互斥，用于保护多线程编程中的数据结构。</p>
</li>
<li><p>相比之下，串行化快照隔离是一种乐观（opt​imist​ic） 的并发控制技术。</p>
</li>
</ul>
<p><a id="org8090f54"></a></p>
<h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h3><ul>
<li>可串行化快照隔离（SSI）一个相当新的算法，避免了先前方法的大部分缺点。它使用乐观的方法，允许事务执行而无需阻塞。当一个事务想要提交时，它会进行检查，如果执行不可串行化，事务就会被中止。</li>
</ul>
<p><a id="orgdaf2622"></a></p>
<h2 id="分布式系统的麻烦"><a href="#分布式系统的麻烦" class="headerlink" title="分布式系统的麻烦"></a>分布式系统的麻烦</h2><ul>
<li><p>过早地声明一个节点已经死了是有问题的：如果这个节点实际上是活着的，并且正在执行一些动作（例如，发送一封电子邮件）​，而另一个节点接管，那么这个动作可能会最终执行两次。</p>
</li>
<li><p>可以在一定程度上同步时钟：最常用的机制是网络时间协议（NTP），它允许根据一组服务器报告的时间来调整计算机时钟【37】​。服务器则从更精确的时间源（如GPS接收机）获取时间。</p>
</li>
<li><p>特别是，如果本地时钟在NTP服务器之前太远，则它可能会被强制重置，看上去好像跳回了先前的时间点。</p>
</li>
<li><p>一些NTP服务器是错误的或者配置错误的，报告的时间可能相差几个小时【43,44】​。</p>
</li>
<li><p>依赖于互联网上的陌生人所告诉你的时间来保证你的系统的正确性，这还挺让人担忧的。</p>
</li>
</ul>
<p><a id="orgc17a52f"></a></p>
<h2 id="一致性与共识"><a href="#一致性与共识" class="headerlink" title="一致性与共识"></a>一致性与共识</h2><ul>
<li>节点能达成一致，在很多场景下都非常重要，例如：<ul>
<li>领导选举</li>
<li>原子提交</li>
</ul>
</li>
</ul>
<p><a id="org2eca161"></a></p>
<h3 id="共识的不可能性"><a href="#共识的不可能性" class="headerlink" title="共识的不可能性"></a>共识的不可能性</h3><ul>
<li><p>你可能已经听说过以作者Fischer，Lynch和Paterson命名的FLP结果【68】​，它证明，如果存在节点可能崩溃的风险，则不存在总是能够达成共识的算法</p>
</li>
<li><p>因此，虽然FLP是关于共识不可能性的重要理论结果，但现实中的分布式系统通常是可以达成共识的。</p>
</li>
<li><p>事实证明2PC是一种共识算法，但不是一个非常好的共识算法【70,71】​。</p>
</li>
<li><p>通过对2PC的学习，我们将继续努力实现更好的一致性算法，比如ZooKeeper（Zab）和etcd（Raft）中使用的算法。</p>
</li>
</ul>
<p><a id="orgb2c36d0"></a></p>
<h3 id="两阶段提交简介"><a href="#两阶段提交简介" class="headerlink" title="两阶段提交简介"></a>两阶段提交简介</h3><ul>
<li>2PC使用一个通常不会出现在单节点事务中的新组件：协调者（coordinator）（也称为事务管理器（transaction manager））​。</li>
</ul>
<p><a id="orgb8033c6"></a></p>
<h3 id="三阶段提交"><a href="#三阶段提交" class="headerlink" title="三阶段提交"></a>三阶段提交</h3><ul>
<li>两阶段提交被称为阻塞（blocking）- 原子提交协议，因为存在2PC可能卡住并等待协调者恢复的情况。</li>
</ul>
<p><a id="org1f27f30"></a></p>
<h3 id="XA事务"><a href="#XA事务" class="headerlink" title="XA事务"></a>XA事务</h3><ul>
<li><p>X&#x2F;Open XA（扩展架构（eXtended Architecture） 的缩写）是跨异构技术实现两阶段提交的标准【76,77】​。</p>
</li>
<li><p>驱动还会向协调者暴露回调接口，协调者可以通过回调来要求参与者准备、提交或中止。</p>
</li>
<li><p>它在事务中跟踪所有的参与者，并在要求它们准备之后收集参与者的响应（通过驱动回调）​，并使用本地磁盘上的日志记录每次事务的决定（提交&#x2F;中止）​。</p>
</li>
</ul>
<p><a id="orgc8411ab"></a></p>
<h3 id="怀疑时持有锁"><a href="#怀疑时持有锁" class="headerlink" title="怀疑时持有锁"></a>怀疑时持有锁</h3><ul>
<li>此外，如果要使用可串行化的隔离等级，则使用两阶段锁定的数据库也必须为事务所读取的行加上共享锁（请参阅“两阶段锁定”​）​。</li>
</ul>
<p><a id="orgf039445"></a></p>
<h3 id="从协调者故障中恢复"><a href="#从协调者故障中恢复" class="headerlink" title="从协调者故障中恢复"></a>从协调者故障中恢复</h3><ul>
<li><p>理论上，如果协调者崩溃并重新启动，它应该干净地从日志中恢复其状态，并解决任何存疑事务。然而在实践中，孤立（orphaned） 的存疑事务确实会出现【89,90】​，即无论出于何种理由，协调者无法确定事务的结果（例如事务日志已经由于软件错误丢失或损坏）​。这些事务无法自动解决，所以它们永远待在数据库中，持有锁并阻塞其他事务。</p>
</li>
<li><p>许多XA的实现都有一个叫做启发式决策（heuristic decisions） 的紧急逃生舱口：允许参与者单方面决定放弃或提交一个存疑事务，而无需协调者做出最终决定【76,77,91</p>
</li>
<li><p>要清楚的是，这里启发式是可能破坏原子性（probably breaking atomicity） 的委婉说法，因为它违背了两阶段提交的系统承诺。因此，启发式决策只是为了逃出灾难性的情况而准备的，而不是为了日常使用的。</p>
</li>
</ul>
<p><a id="orgbd8adbd"></a></p>
<h3 id="容错共识"><a href="#容错共识" class="headerlink" title="容错共识"></a>容错共识</h3><ul>
<li><p>在这种形式下，共识算法必须满足以下性质【25】​：xiii</p>
<ul>
<li>一致同意（Uniform agreement）没有两个节点的决定不同。</li>
<li>完整性（Integrity）没有节点决定两次。</li>
<li>有效性（Validity）如果一个节点决定了值 v ，则 v 由某个节点所提议。</li>
<li>终止（Termination） 由所有未崩溃的节点来最终决定值。</li>
</ul>
</li>
<li><p>一致同意和完整性属性定义了共识的核心思想：所有人都决定了相同的结果，一旦决定了，你就不能改变主意。</p>
</li>
</ul>
<p><a id="org962ee39"></a></p>
<h3 id="共识算法和全序广播"><a href="#共识算法和全序广播" class="headerlink" title="共识算法和全序广播"></a>共识算法和全序广播</h3><ul>
<li>最著名的容错共识算法是视图戳复制（VSR, Viewstamped Replication）【94,95】​，Paxos 【96,97,98,99】​，Raft 【22,100,101】以及 Zab 【15,21,102】 。</li>
</ul>
<p><a id="orgf3a765f"></a></p>
<h3 id="单领导者复制与共识"><a href="#单领导者复制与共识" class="headerlink" title="单领导者复制与共识"></a>单领导者复制与共识</h3><ul>
<li><p>在第五章中，我们讨论了单领导者复制（请参阅“领导者与追随者”​）​，它将所有的写入操作都交给主库，并以相同的顺序将它们应用到从库，从而使副本保持在最新状态。这实际上不就是一个全序广播吗？</p>
</li>
<li><p>但如果心跳停止的持续时间超出会话超时，ZooKeeper会宣告该会话已死亡。</p>
<ul>
<li>评论：所以在这种情况下一般客户端都不会去处理太重业务导致会话超时</li>
</ul>
</li>
</ul>
<p><a id="org0931b1d"></a></p>
<h3 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h3><ul>
<li><p>但如果该领导者失效，或者如果网络中断导致领导者不可达，这样的系统就无法取得任何进展。应对这种情况可以有三种方法：</p>
</li>
<li><p>等待领导者恢复，接受系统将在这段时间阻塞的事实。</p>
</li>
<li><p>人工故障切换，让人类选择一个新的领导者节点，并重新配置系统使之生效，许多关系型数据库都采用这种方方式。</p>
</li>
<li><p>使用算法自动选择一个新的领导者。这种方法需要一种共识算法，使用成熟的算法来正确处理恶劣的网络条件是明智之举【107】​。</p>
</li>
</ul>
<p><a id="org934c8d3"></a></p>
<h1 id="衍生数据"><a href="#衍生数据" class="headerlink" title="衍生数据"></a>衍生数据</h1><p><a id="org8e6f5da"></a></p>
<h2 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h2><ul>
<li><p>使用日志进行消息存储</p>
</li>
<li><p>在每个分区内，代理为每个消息分配一个单调递增的序列号或偏移量（offset）（在图11-3中，框中的数字是消息偏移量）​。这种序列号是有意义的，因为分区是仅追加写入的，所以分区内的消息是完全有序的。没有跨不同分区的顺序保证。</p>
</li>
<li><p>Apache Kafka 【17,18】​，Amazon Kinesis Streams 【19】和Twitter的DistributedLog 【20,21】都是基于日志的消息代理。</p>
</li>
<li><p>正如我们在本书中所看到的，没有一个系统能够满足所有的数据存储、查询和处理需求。</p>
</li>
<li><p>如果周期性的完整数据库转储过于缓慢，有时会使用的替代方法是双写（dual write），其中应用代码在数据变更时明确写入每个系统：例如，首先写入数据库，然后更新搜索索引，然后使缓存项失效（甚至同时执行这些写入）​。</p>
</li>
<li><p>但是，双写有一些严重的问题，其中一个是竞争条件，如图11-4所示。</p>
</li>
<li><p>在数据库中X首先被设置为A，然后被设置为B，而在搜索索引处，写入以相反的顺序到达</p>
</li>
<li><p>双重写入的另一个问题是，其中一个写入可能会失败，而另一个成功。这是一个容错问题，而不是一个并发问题，但也会造成两个系统互相不一致的结果。</p>
</li>
<li><p>如果你只能保留有限的历史日志，则每次要添加新的衍生数据系统时，都需要做一次快照。但日志压缩（log compaction） 提供了一个很好的备选方案。</p>
</li>
<li><p>原理很简单：存储引擎定期在日志中查找具有相同键的记录，丢掉所有重复的内容，并只保留每个键的最新更新。这个压缩与合并过程在后台运行。</p>
</li>
<li><p>你可以从压缩日志主题的零偏移量处启动新的消费者，然后依次扫描日志中的所有消息。日志能保证包含数据库中每个键的最新值（也可能是一些较旧的值）—— 换句话说，你可以使用它来获取数据库内容的完整副本，而无需从CDC源数据库取一个快照。</p>
</li>
<li><p>我们在这里讨论的想法和事件溯源（Event Sourcing） 之间有一些相似之处，这是一个在 领域驱动设计（domain-driven design, DDD） 社区中折腾出来的技术。我们将简要讨论事件溯源，因为它包含了一些关于流处理系统的有用想法。</p>
</li>
<li><p>你可以将事件中的数据写入数据库、缓存、搜索索引或类似的存储系统，然后能被其他客户端查询</p>
</li>
</ul>
<p><a id="org43fc32d"></a></p>
<h2 id="数据系统的未来"><a href="#数据系统的未来" class="headerlink" title="数据系统的未来"></a>数据系统的未来</h2><p><a id="org9fb0824"></a></p>
<h3 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h3><ul>
<li><p>Lambda架构的核心思想是通过将不可变事件附加到不断增长的数据集来记录传入数据，这类似于事件溯源（请参阅“事件溯源”​）​。为了从这些事件中衍生出读取优化的视图， Lambda架构建议并行运行两个不同的系统：批处理系统（如Hadoop MapReduce）和独立的流处理系统（如Storm）​。</p>
</li>
<li><p>推广这样的原则：在不可变事件流上建立衍生视图，并在需要时重新处理事件。</p>
</li>
</ul>
<p><a id="org5c52457"></a></p>
<h3 id="分拆系统vs集成系统"><a href="#分拆系统vs集成系统" class="headerlink" title="分拆系统vs集成系统"></a>分拆系统vs集成系统</h3><ul>
<li>正如在前言中所说的那样，为了不需要的规模而构建系统是白费精力，而且可能会将你锁死在一个不灵活的设计中。实际上，这是一种过早优化的形式。</li>
</ul>
<p><a id="org0929748"></a></p>
<h3 id="在数据系统中应用端到端思考"><a href="#在数据系统中应用端到端思考" class="headerlink" title="在数据系统中应用端到端思考"></a>在数据系统中应用端到端思考</h3><ul>
<li><p>这将我带回最初的论点：仅仅因为应用使用了提供相对较强安全属性的数据系统，例如可串行化的事务，并不意味着应用的数据就不会丢失或损坏了。应用本身也需要采取端到端的措施，例如除重。</p>
<ul>
<li>评论：数据系统的安全性和可靠性很高的情况很好，但不能仅仅依靠底层系统自身的能力。它只能处理绝大部分的情况下，但大部分异常情况的处理也需要应用系统来保障。</li>
</ul>
</li>
<li><p>我们拒绝使用分布式事务是因为它开销太大，结果我们最后不得不在应用代码中重新实现容错机制。</p>
</li>
</ul>
<p><a id="orgba709fb"></a></p>
<h3 id="强制约束"><a href="#强制约束" class="headerlink" title="强制约束"></a>强制约束</h3><ul>
<li>让我们思考一下在分拆数据库上下文中的正确性（correctness）。我们看到端到端的除重可以通过从客户端一路透传到数据库的请求ID实现。那么其他类型的约束呢？我们先来特别关注一下唯一性约束 —— 例如我们在例12-2中所依赖的约束。在“约束和唯一性保证”中，我们看到了几个其他需要强制实施唯一性的应用功能例子：用户名或电子邮件地址必须唯一标识用户，文件存储</li>
</ul>
<p><a id="org5e50a64"></a></p>
<h3 id="唯一性约束需要达成共识"><a href="#唯一性约束需要达成共识" class="headerlink" title="唯一性约束需要达成共识"></a>唯一性约束需要达成共识</h3><ul>
<li><p>达成这一共识的最常见方式是使单个节点作为领导，并使其负责所有决策。</p>
</li>
<li><p>唯一性检查可以通过对唯一性字段分区做横向伸缩</p>
</li>
<li><p>但异步多主复制排除在外，</p>
</li>
</ul>
<p><a id="orge2f5be9"></a></p>
<h3 id="及时性与完整性"><a href="#及时性与完整性" class="headerlink" title="及时性与完整性"></a>及时性与完整性</h3><ul>
<li>违反及时性，​“最终一致性”​；违反完整性，​“永无一致性”​。</li>
</ul>
<p><a id="org17ed944"></a></p>
<h3 id="宽松地解释约束"><a href="#宽松地解释约束" class="headerlink" title="宽松地解释约束"></a>宽松地解释约束</h3><ul>
<li>如果两个人同时注册了相同的用户名或预订了相同的座位，你可以给其中一个人发消息道歉，并要求他们选择一个不同的用户名。这种纠正错误的变化被称为补偿性事务（compensating transaction）【59,60】​。</li>
</ul>
<p><a id="orgea0a7b5"></a></p>
<h3 id="做正确的事情"><a href="#做正确的事情" class="headerlink" title="做正确的事情"></a>做正确的事情</h3><ul>
<li>我们，建立这些系统的工程师，有责任去仔细考虑这些后果，并有意识地决定，我们希望生活在怎样的世界中。<ul>
<li>评论：把事情做正确的同时，去做正确的事。</li>
</ul>
</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"><i class="fa fa-tag"></i> 笔记</a>
              <a href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag"><i class="fa fa-tag"></i> 读书</a>
              <a href="/tags/%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6/" rel="tag"><i class="fa fa-tag"></i> 微信读书</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2024/07/18/AE%E9%A1%B9%E7%9B%AE%E5%A4%8D%E7%9B%98/" rel="prev" title="AE项目复盘">
                  <i class="fa fa-angle-left"></i> AE项目复盘
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2024/10/15/hexo%E5%8D%87%E7%BA%A7/" rel="next" title="hexo升级">
                  hexo升级 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Yellow</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">122k</span>
  </span>
</div>

    </div>
  </footer>

    
​
  <script color="0, 0, 255" 
          opacity="0.5" 
          zIndex="-1" 
          count="120" 
          src="https://cdn.jsdelivr.net/npm/canvas-nest.js@1/dist/canvas-nest.js">
  </script>
​
  

  

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




 

<script>
  var OriginTitile = document.title;
  var titleTime;
  //换网站的logo
  function selfSetIcon(url){
        var links = document.getElementsByTagName('link') 
        for (var i = 0; i < links.length; i++) { 
            var link = links[i]
            var rel = link.rel; 
            var count = 0;
            rel = rel.toLowerCase(); 
            if (rel.indexOf('icon') == 0) { 
                count++;
                link.href = url;
                if(count == 2)
                    break;
            }
        }
    }
  
  document.addEventListener("visibilitychange", function() {
    if (document.hidden) {
      document.title = "(●—●)喔噢，崩溃了~|" + OriginTitile;
      // selfSetIcon("");
      clearTimeout(titleTime);
    } else {
      // selfSetIcon("/images/favicon-32x32-next.png");
      document.title = "φ(>ω<*) 咦！又好了！|" + OriginTitile;
      titleTime = setTimeout(function() {
        document.title = OriginTitile;
        
      }, 2000);
    }
  });
  
</script>

</body>
</html>
<script type="text/javascript" src="/js/src/click.js"></script>